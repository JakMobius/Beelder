{
  "version": 3,
  "sources": [
    "../node_modules/browser-pack/_prelude.js",
    "../node_modules/@babel/runtime/helpers/interopRequireDefault.js",
    "../node_modules/@babel/runtime/helpers/interopRequireWildcard.js",
    "../node_modules/@babel/runtime/helpers/typeof.js",
    "../node_modules/balanced-match/index.js",
    "../node_modules/brace-expansion/index.js",
    "../node_modules/browser-resolve/index.js",
    "../node_modules/concat-map/index.js",
    "../node_modules/function-bind/implementation.js",
    "../node_modules/function-bind/index.js",
    "../node_modules/has/src/index.js",
    "../node_modules/is-core-module/core.json",
    "../node_modules/is-core-module/index.js",
    "../node_modules/minimatch/minimatch.js",
    "../node_modules/path-parse/index.js",
    "../node_modules/resolve/index.js",
    "../node_modules/resolve/lib/async.js",
    "../node_modules/resolve/lib/caller.js",
    "../node_modules/resolve/lib/core.js",
    "../node_modules/resolve/lib/is-core.js",
    "../node_modules/resolve/lib/node-modules-paths.js",
    "../node_modules/resolve/lib/normalize-options.js",
    "../node_modules/resolve/lib/sync.js",
    "action.ts",
    "async-event-emitter.ts",
    "base-scheme.ts",
    "beelder.ts",
    "build-cache.ts",
    "event-handler-block.ts",
    "javascript-bundler/bundler-plugin-factory.ts",
    "javascript-bundler/bundler-plugin.ts",
    "javascript-bundler/bundler.ts",
    "javascript-bundler/packer/packer-ast-watcher.ts",
    "javascript-bundler/packer/packer-cache.ts",
    "javascript-bundler/packer/packer-file-storage.ts",
    "javascript-bundler/packer/packer-file.ts",
    "javascript-bundler/packer/packer-project-storage.ts",
    "javascript-bundler/packer/packer-storage.ts",
    "javascript-bundler/packer/packer.ts",
    "javascript-bundler/plugins/base.ts",
    "javascript-bundler/plugins/json-comment-replacer.ts",
    "javascript-bundler/plugins/resource-plugin.ts",
    "reference.ts",
    "scheme.ts",
    "schemes/bundle-javascript.ts",
    "schemes/compile-scss.ts",
    "schemes/copy.ts",
    "schemes/create-shader-library.ts",
    "schemes/delete.ts",
    "schemes/require-target.ts",
    "schemes/texture-atlas.ts",
    "timings.ts",
    "utils.ts",
    "index.ts"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC35BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClMe,MAAM,aAAN,CAAoB;AAK/B,EAAA,WAAW,CAAC,MAAD,EAA8B,MAA9B,EAAqD;AAAA,SAFhE,MAEgE;AAC5D,SAAK,MAAL,GAAc,MAAd;AACH;;AAEM,EAAA,eAAe,GAAoB;AACtC,WAAO,IAAP;AACH;;AAEM,EAAA,UAAU,GAA8B;AAC3C,WAAO,IAAP;AACH;;AAEe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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;",
    "var _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nmodule.exports = _interopRequireWildcard;",
    "function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;",
    "'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n",
    "var concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n",
    "// builtin\nvar fs = require('fs');\nvar path = require('path');\n\n// vendor\nvar resv = require('resolve');\n\n// given a path, create an array of node_module paths for it\n// borrowed from substack/resolve\nfunction nodeModulesPaths (start, cb) {\n    var splitRe = process.platform === 'win32' ? /[\\/\\\\]/ : /\\/+/;\n    var parts = start.split(splitRe);\n\n    var dirs = [];\n    for (var i = parts.length - 1; i >= 0; i--) {\n        if (parts[i] === 'node_modules') continue;\n        var dir = path.join.apply(\n            path, parts.slice(0, i + 1).concat(['node_modules'])\n        );\n        if (!parts[0].match(/([A-Za-z]:)/)) {\n            dir = '/' + dir;\n        }\n        dirs.push(dir);\n    }\n    return dirs;\n}\n\nfunction find_shims_in_package(pkgJson, cur_path, shims, browser) {\n    try {\n        var info = JSON.parse(pkgJson);\n    }\n    catch (err) {\n        err.message = pkgJson + ' : ' + err.message\n        throw err;\n    }\n\n    var replacements = getReplacements(info, browser);\n\n    // no replacements, skip shims\n    if (!replacements) {\n        return;\n    }\n\n    // if browser mapping is a string\n    // then it just replaces the main entry point\n    if (typeof replacements === 'string') {\n        var key = path.resolve(cur_path, info.main || 'index.js');\n        shims[key] = path.resolve(cur_path, replacements);\n        return;\n    }\n\n    // http://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders\n    Object.keys(replacements).forEach(function(key) {\n        var val;\n        if (replacements[key] === false) {\n            val = path.normalize(__dirname + '/empty.js');\n        }\n        else {\n            val = replacements[key];\n            // if target is a relative path, then resolve\n            // otherwise we assume target is a module\n            if (val[0] === '.') {\n                val = path.resolve(cur_path, val);\n            }\n        }\n\n        if (key[0] === '/' || key[0] === '.') {\n            // if begins with / ../ or ./ then we must resolve to a full path\n            key = path.resolve(cur_path, key);\n        }\n        shims[key] = val;\n    });\n\n    [ '.js', '.json' ].forEach(function (ext) {\n        Object.keys(shims).forEach(function (key) {\n            if (!shims[key + ext]) {\n                shims[key + ext] = shims[key];\n            }\n        });\n    });\n}\n\n// paths is mutated\n// load shims from first package.json file found\nfunction load_shims(paths, browser, cb) {\n    // identify if our file should be replaced per the browser field\n    // original filename|id -> replacement\n    var shims = Object.create(null);\n\n    (function next() {\n        var cur_path = paths.shift();\n        if (!cur_path) {\n            return cb(null, shims);\n        }\n\n        var pkg_path = path.join(cur_path, 'package.json');\n\n        fs.readFile(pkg_path, 'utf8', function(err, data) {\n            if (err) {\n                // ignore paths we can't open\n                // avoids an exists check\n                if (err.code === 'ENOENT') {\n                    return next();\n                }\n\n                return cb(err);\n            }\n            try {\n                find_shims_in_package(data, cur_path, shims, browser);\n                return cb(null, shims);\n            }\n            catch (err) {\n                return cb(err);\n            }\n        });\n    })();\n};\n\n// paths is mutated\n// synchronously load shims from first package.json file found\nfunction load_shims_sync(paths, browser) {\n    // identify if our file should be replaced per the browser field\n    // original filename|id -> replacement\n    var shims = Object.create(null);\n    var cur_path;\n\n    while (cur_path = paths.shift()) {\n        var pkg_path = path.join(cur_path, 'package.json');\n\n        try {\n            var data = fs.readFileSync(pkg_path, 'utf8');\n            find_shims_in_package(data, cur_path, shims, browser);\n            return shims;\n        }\n        catch (err) {\n            // ignore paths we can't open\n            // avoids an exists check\n            if (err.code === 'ENOENT') {\n                continue;\n            }\n\n            throw err;\n        }\n    }\n    return shims;\n}\n\nfunction build_resolve_opts(opts, base) {\n    var packageFilter = opts.packageFilter;\n    var browser = normalizeBrowserFieldName(opts.browser)\n\n    opts.basedir = base;\n    opts.packageFilter = function (info, pkgdir) {\n        if (packageFilter) info = packageFilter(info, pkgdir);\n\n        var replacements = getReplacements(info, browser);\n\n        // no browser field, keep info unchanged\n        if (!replacements) {\n            return info;\n        }\n\n        info[browser] = replacements;\n\n        // replace main\n        if (typeof replacements === 'string') {\n            info.main = replacements;\n            return info;\n        }\n\n        var replace_main = replacements[info.main || './index.js'] ||\n            replacements['./' + info.main || './index.js'];\n\n        info.main = replace_main || info.main;\n        return info;\n    };\n\n    var pathFilter = opts.pathFilter;\n    opts.pathFilter = function(info, resvPath, relativePath) {\n        if (relativePath[0] != '.') {\n            relativePath = './' + relativePath;\n        }\n        var mappedPath;\n        if (pathFilter) {\n            mappedPath = pathFilter.apply(this, arguments);\n        }\n        if (mappedPath) {\n            return mappedPath;\n        }\n\n        var replacements = info[browser];\n        if (!replacements) {\n            return;\n        }\n\n        mappedPath = replacements[relativePath];\n        if (!mappedPath && path.extname(relativePath) === '') {\n            mappedPath = replacements[relativePath + '.js'];\n            if (!mappedPath) {\n                mappedPath = replacements[relativePath + '.json'];\n            }\n        }\n        return mappedPath;\n    };\n\n    return opts;\n}\n\nfunction resolve(id, opts, cb) {\n\n    // opts.filename\n    // opts.paths\n    // opts.modules\n    // opts.packageFilter\n\n    opts = opts || {};\n    opts.filename = opts.filename || '';\n\n    var base = path.dirname(opts.filename);\n\n    if (opts.basedir) {\n        base = opts.basedir;\n    }\n\n    var paths = nodeModulesPaths(base);\n\n    if (opts.paths) {\n        paths.push.apply(paths, opts.paths);\n    }\n\n    paths = paths.map(function(p) {\n        return path.dirname(p);\n    });\n\n    // we must always load shims because the browser field could shim out a module\n    load_shims(paths, opts.browser, function(err, shims) {\n        if (err) {\n            return cb(err);\n        }\n\n        var resid = path.resolve(opts.basedir || path.dirname(opts.filename), id);\n        if (shims[id] || shims[resid]) {\n            var xid = shims[id] ? id : resid;\n            // if the shim was is an absolute path, it was fully resolved\n            if (shims[xid][0] === '/') {\n                return resv(shims[xid], build_resolve_opts(opts, base), function(err, full, pkg) {\n                    cb(null, full, pkg);\n                });\n            }\n\n            // module -> alt-module shims\n            id = shims[xid];\n        }\n\n        var modules = opts.modules || Object.create(null);\n        var shim_path = modules[id];\n        if (shim_path) {\n            return cb(null, shim_path);\n        }\n\n        // our browser field resolver\n        // if browser field is an object tho?\n        var full = resv(id, build_resolve_opts(opts, base), function(err, full, pkg) {\n            if (err) {\n                return cb(err);\n            }\n\n            var resolved = (shims) ? shims[full] || full : full;\n            cb(null, resolved, pkg);\n        });\n    });\n};\n\nresolve.sync = function (id, opts) {\n\n    // opts.filename\n    // opts.paths\n    // opts.modules\n    // opts.packageFilter\n\n    opts = opts || {};\n    opts.filename = opts.filename || '';\n\n    var base = path.dirname(opts.filename);\n\n    if (opts.basedir) {\n        base = opts.basedir;\n    }\n\n    var paths = nodeModulesPaths(base);\n\n    if (opts.paths) {\n        paths.push.apply(paths, opts.paths);\n    }\n\n    paths = paths.map(function(p) {\n        return path.dirname(p);\n    });\n\n    // we must always load shims because the browser field could shim out a module\n    var shims = load_shims_sync(paths, opts.browser);\n    var resid = path.resolve(opts.basedir || path.dirname(opts.filename), id);\n\n    if (shims[id] || shims[resid]) {\n        var xid = shims[id] ? id : resid;\n        // if the shim was is an absolute path, it was fully resolved\n        if (shims[xid][0] === '/') {\n            return resv.sync(shims[xid], build_resolve_opts(opts, base));\n        }\n\n        // module -> alt-module shims\n        id = shims[xid];\n    }\n\n    var modules = opts.modules || Object.create(null);\n    var shim_path = modules[id];\n    if (shim_path) {\n        return shim_path;\n    }\n\n    // our browser field resolver\n    // if browser field is an object tho?\n    var full = resv.sync(id, build_resolve_opts(opts, base));\n\n    return (shims) ? shims[full] || full : full;\n};\n\nfunction normalizeBrowserFieldName(browser) {\n    return browser || 'browser';\n}\n\nfunction getReplacements(info, browser) {\n    browser = normalizeBrowserFieldName(browser);\n    var replacements = info[browser] || info.browser;\n\n    // support legacy browserify field for easier migration from legacy\n    // many packages used this field historically\n    if (typeof info.browserify === 'string' && !replacements) {\n        replacements = info.browserify;\n    }\n\n    return replacements;\n}\n\nmodule.exports = resolve;\n",
    "module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n",
    "'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n",
    "'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n",
    "'use strict';\n\nvar bind = require('function-bind');\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n",
    "module.exports={\n\t\"assert\": true,\n\t\"assert/strict\": \">= 15\",\n\t\"async_hooks\": \">= 8\",\n\t\"buffer_ieee754\": \"< 0.9.7\",\n\t\"buffer\": true,\n\t\"child_process\": true,\n\t\"cluster\": true,\n\t\"console\": true,\n\t\"constants\": true,\n\t\"crypto\": true,\n\t\"_debug_agent\": \">= 1 && < 8\",\n\t\"_debugger\": \"< 8\",\n\t\"dgram\": true,\n\t\"diagnostics_channel\": \">= 15.1\",\n\t\"dns\": true,\n\t\"dns/promises\": \">= 15\",\n\t\"domain\": \">= 0.7.12\",\n\t\"events\": true,\n\t\"freelist\": \"< 6\",\n\t\"fs\": true,\n\t\"fs/promises\": [\">= 10 && < 10.1\", \">= 14\"],\n\t\"_http_agent\": \">= 0.11.1\",\n\t\"_http_client\": \">= 0.11.1\",\n\t\"_http_common\": \">= 0.11.1\",\n\t\"_http_incoming\": \">= 0.11.1\",\n\t\"_http_outgoing\": \">= 0.11.1\",\n\t\"_http_server\": \">= 0.11.1\",\n\t\"http\": true,\n\t\"http2\": \">= 8.8\",\n\t\"https\": true,\n\t\"inspector\": \">= 8.0.0\",\n\t\"_linklist\": \"< 8\",\n\t\"module\": true,\n\t\"net\": true,\n\t\"node-inspect/lib/_inspect\": \">= 7.6.0 && < 12\",\n\t\"node-inspect/lib/internal/inspect_client\": \">= 7.6.0 && < 12\",\n\t\"node-inspect/lib/internal/inspect_repl\": \">= 7.6.0 && < 12\",\n\t\"os\": true,\n\t\"path\": true,\n\t\"path/posix\": \">= 15.3\",\n\t\"path/win32\": \">= 15.3\",\n\t\"perf_hooks\": \">= 8.5\",\n\t\"process\": \">= 1\",\n\t\"punycode\": true,\n\t\"querystring\": true,\n\t\"readline\": true,\n\t\"repl\": true,\n\t\"smalloc\": \">= 0.11.5 && < 3\",\n\t\"_stream_duplex\": \">= 0.9.4\",\n\t\"_stream_transform\": \">= 0.9.4\",\n\t\"_stream_wrap\": \">= 1.4.1\",\n\t\"_stream_passthrough\": \">= 0.9.4\",\n\t\"_stream_readable\": \">= 0.9.4\",\n\t\"_stream_writable\": \">= 0.9.4\",\n\t\"stream\": true,\n\t\"stream/promises\": \">= 15\",\n\t\"string_decoder\": true,\n\t\"sys\": [\">= 0.6 && < 0.7\", \">= 0.8\"],\n\t\"timers\": true,\n\t\"timers/promises\": \">= 15\",\n\t\"_tls_common\": \">= 0.11.13\",\n\t\"_tls_legacy\": \">= 0.11.3 && < 10\",\n\t\"_tls_wrap\": \">= 0.11.3\",\n\t\"tls\": true,\n\t\"trace_events\": \">= 10\",\n\t\"tty\": true,\n\t\"url\": true,\n\t\"util\": true,\n\t\"util/types\": \">= 15.3\",\n\t\"v8/tools/arguments\": \">= 10 && < 12\",\n\t\"v8/tools/codemap\": [\">= 4.4.0 && < 5\", \">= 5.2.0 && < 12\"],\n\t\"v8/tools/consarray\": [\">= 4.4.0 && < 5\", \">= 5.2.0 && < 12\"],\n\t\"v8/tools/csvparser\": [\">= 4.4.0 && < 5\", \">= 5.2.0 && < 12\"],\n\t\"v8/tools/logreader\": [\">= 4.4.0 && < 5\", \">= 5.2.0 && < 12\"],\n\t\"v8/tools/profile_view\": [\">= 4.4.0 && < 5\", \">= 5.2.0 && < 12\"],\n\t\"v8/tools/splaytree\": [\">= 4.4.0 && < 5\", \">= 5.2.0 && < 12\"],\n\t\"v8\": \">= 1\",\n\t\"vm\": true,\n\t\"wasi\": \">= 13.4 && < 13.5\",\n\t\"worker_threads\": \">= 11.7\",\n\t\"zlib\": true\n}\n",
    "'use strict';\n\nvar has = require('has');\n\nfunction specifierIncluded(current, specifier) {\n\tvar nodeParts = current.split('.');\n\tvar parts = specifier.split(' ');\n\tvar op = parts.length > 1 ? parts[0] : '=';\n\tvar versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');\n\n\tfor (var i = 0; i < 3; ++i) {\n\t\tvar cur = parseInt(nodeParts[i] || 0, 10);\n\t\tvar ver = parseInt(versionParts[i] || 0, 10);\n\t\tif (cur === ver) {\n\t\t\tcontinue; // eslint-disable-line no-restricted-syntax, no-continue\n\t\t}\n\t\tif (op === '<') {\n\t\t\treturn cur < ver;\n\t\t}\n\t\tif (op === '>=') {\n\t\t\treturn cur >= ver;\n\t\t}\n\t\treturn false;\n\t}\n\treturn op === '>=';\n}\n\nfunction matchesRange(current, range) {\n\tvar specifiers = range.split(/ ?&& ?/);\n\tif (specifiers.length === 0) {\n\t\treturn false;\n\t}\n\tfor (var i = 0; i < specifiers.length; ++i) {\n\t\tif (!specifierIncluded(current, specifiers[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction versionIncluded(nodeVersion, specifierValue) {\n\tif (typeof specifierValue === 'boolean') {\n\t\treturn specifierValue;\n\t}\n\n\tvar current = typeof nodeVersion === 'undefined'\n\t\t? process.versions && process.versions.node && process.versions.node\n\t\t: nodeVersion;\n\n\tif (typeof current !== 'string') {\n\t\tthrow new TypeError(typeof nodeVersion === 'undefined' ? 'Unable to determine current node version' : 'If provided, a valid node version is required');\n\t}\n\n\tif (specifierValue && typeof specifierValue === 'object') {\n\t\tfor (var i = 0; i < specifierValue.length; ++i) {\n\t\t\tif (matchesRange(current, specifierValue[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\treturn matchesRange(current, specifierValue);\n}\n\nvar data = require('./core.json');\n\nmodule.exports = function isCore(x, nodeVersion) {\n\treturn has(data, x) && versionIncluded(nodeVersion, data[x]);\n};\n",
    "module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n",
    "'use strict';\n\nvar isWindows = process.platform === 'win32';\n\n// Regex to split a windows path into three parts: [*, device, slash,\n// tail] windows-only\nvar splitDeviceRe =\n    /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\n// Regex to split the tail part of the above into [*, dir, basename, ext]\nvar splitTailRe =\n    /^([\\s\\S]*?)((?:\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))(?:[\\\\\\/]*)$/;\n\nvar win32 = {};\n\n// Function to split a filename into [root, dir, basename, ext]\nfunction win32SplitPath(filename) {\n  // Separate device+slash from tail\n  var result = splitDeviceRe.exec(filename),\n      device = (result[1] || '') + (result[2] || ''),\n      tail = result[3] || '';\n  // Split the tail into dir, basename and extension\n  var result2 = splitTailRe.exec(tail),\n      dir = result2[1],\n      basename = result2[2],\n      ext = result2[3];\n  return [device, dir, basename, ext];\n}\n\nwin32.parse = function(pathString) {\n  if (typeof pathString !== 'string') {\n    throw new TypeError(\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\n    );\n  }\n  var allParts = win32SplitPath(pathString);\n  if (!allParts || allParts.length !== 4) {\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n  }\n  return {\n    root: allParts[0],\n    dir: allParts[0] + allParts[1].slice(0, -1),\n    base: allParts[2],\n    ext: allParts[3],\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n  };\n};\n\n\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar posix = {};\n\n\nfunction posixSplitPath(filename) {\n  return splitPathRe.exec(filename).slice(1);\n}\n\n\nposix.parse = function(pathString) {\n  if (typeof pathString !== 'string') {\n    throw new TypeError(\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\n    );\n  }\n  var allParts = posixSplitPath(pathString);\n  if (!allParts || allParts.length !== 4) {\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n  }\n  allParts[1] = allParts[1] || '';\n  allParts[2] = allParts[2] || '';\n  allParts[3] = allParts[3] || '';\n\n  return {\n    root: allParts[0],\n    dir: allParts[0] + allParts[1].slice(0, -1),\n    base: allParts[2],\n    ext: allParts[3],\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n  };\n};\n\n\nif (isWindows)\n  module.exports = win32.parse;\nelse /* posix */\n  module.exports = posix.parse;\n\nmodule.exports.posix = posix.parse;\nmodule.exports.win32 = win32.parse;\n",
    "var async = require('./lib/async');\nasync.core = require('./lib/core');\nasync.isCore = require('./lib/is-core');\nasync.sync = require('./lib/sync');\n\nmodule.exports = async;\n",
    "var fs = require('fs');\nvar path = require('path');\nvar caller = require('./caller');\nvar nodeModulesPaths = require('./node-modules-paths');\nvar normalizeOptions = require('./normalize-options');\nvar isCore = require('is-core-module');\n\nvar realpathFS = fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;\n\nvar defaultIsFile = function isFile(file, cb) {\n    fs.stat(file, function (err, stat) {\n        if (!err) {\n            return cb(null, stat.isFile() || stat.isFIFO());\n        }\n        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);\n        return cb(err);\n    });\n};\n\nvar defaultIsDir = function isDirectory(dir, cb) {\n    fs.stat(dir, function (err, stat) {\n        if (!err) {\n            return cb(null, stat.isDirectory());\n        }\n        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);\n        return cb(err);\n    });\n};\n\nvar defaultRealpath = function realpath(x, cb) {\n    realpathFS(x, function (realpathErr, realPath) {\n        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);\n        else cb(null, realpathErr ? x : realPath);\n    });\n};\n\nvar maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {\n    if (opts && opts.preserveSymlinks === false) {\n        realpath(x, cb);\n    } else {\n        cb(null, x);\n    }\n};\n\nvar defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) {\n    readFile(pkgfile, function (readFileErr, body) {\n        if (readFileErr) cb(readFileErr);\n        else {\n            try {\n                var pkg = JSON.parse(body);\n                cb(null, pkg);\n            } catch (jsonErr) {\n                cb(null);\n            }\n        }\n    });\n};\n\nvar getPackageCandidates = function getPackageCandidates(x, start, opts) {\n    var dirs = nodeModulesPaths(start, opts, x);\n    for (var i = 0; i < dirs.length; i++) {\n        dirs[i] = path.join(dirs[i], x);\n    }\n    return dirs;\n};\n\nmodule.exports = function resolve(x, options, callback) {\n    var cb = callback;\n    var opts = options;\n    if (typeof options === 'function') {\n        cb = opts;\n        opts = {};\n    }\n    if (typeof x !== 'string') {\n        var err = new TypeError('Path must be a string.');\n        return process.nextTick(function () {\n            cb(err);\n        });\n    }\n\n    opts = normalizeOptions(x, opts);\n\n    var isFile = opts.isFile || defaultIsFile;\n    var isDirectory = opts.isDirectory || defaultIsDir;\n    var readFile = opts.readFile || fs.readFile;\n    var realpath = opts.realpath || defaultRealpath;\n    var readPackage = opts.readPackage || defaultReadPackage;\n    if (opts.readFile && opts.readPackage) {\n        var conflictErr = new TypeError('`readFile` and `readPackage` are mutually exclusive.');\n        return process.nextTick(function () {\n            cb(conflictErr);\n        });\n    }\n    var packageIterator = opts.packageIterator;\n\n    var extensions = opts.extensions || ['.js'];\n    var includeCoreModules = opts.includeCoreModules !== false;\n    var basedir = opts.basedir || path.dirname(caller());\n    var parent = opts.filename || basedir;\n\n    opts.paths = opts.paths || [];\n\n    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory\n    var absoluteStart = path.resolve(basedir);\n\n    maybeRealpath(\n        realpath,\n        absoluteStart,\n        opts,\n        function (err, realStart) {\n            if (err) cb(err);\n            else init(realStart);\n        }\n    );\n\n    var res;\n    function init(basedir) {\n        if ((/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/).test(x)) {\n            res = path.resolve(basedir, x);\n            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';\n            if ((/\\/$/).test(x) && res === basedir) {\n                loadAsDirectory(res, opts.package, onfile);\n            } else loadAsFile(res, opts.package, onfile);\n        } else if (includeCoreModules && isCore(x)) {\n            return cb(null, x);\n        } else loadNodeModules(x, basedir, function (err, n, pkg) {\n            if (err) cb(err);\n            else if (n) {\n                return maybeRealpath(realpath, n, opts, function (err, realN) {\n                    if (err) {\n                        cb(err);\n                    } else {\n                        cb(null, realN, pkg);\n                    }\n                });\n            } else {\n                var moduleError = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n                moduleError.code = 'MODULE_NOT_FOUND';\n                cb(moduleError);\n            }\n        });\n    }\n\n    function onfile(err, m, pkg) {\n        if (err) cb(err);\n        else if (m) cb(null, m, pkg);\n        else loadAsDirectory(res, function (err, d, pkg) {\n            if (err) cb(err);\n            else if (d) {\n                maybeRealpath(realpath, d, opts, function (err, realD) {\n                    if (err) {\n                        cb(err);\n                    } else {\n                        cb(null, realD, pkg);\n                    }\n                });\n            } else {\n                var moduleError = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n                moduleError.code = 'MODULE_NOT_FOUND';\n                cb(moduleError);\n            }\n        });\n    }\n\n    function loadAsFile(x, thePackage, callback) {\n        var loadAsFilePackage = thePackage;\n        var cb = callback;\n        if (typeof loadAsFilePackage === 'function') {\n            cb = loadAsFilePackage;\n            loadAsFilePackage = undefined;\n        }\n\n        var exts = [''].concat(extensions);\n        load(exts, x, loadAsFilePackage);\n\n        function load(exts, x, loadPackage) {\n            if (exts.length === 0) return cb(null, undefined, loadPackage);\n            var file = x + exts[0];\n\n            var pkg = loadPackage;\n            if (pkg) onpkg(null, pkg);\n            else loadpkg(path.dirname(file), onpkg);\n\n            function onpkg(err, pkg_, dir) {\n                pkg = pkg_;\n                if (err) return cb(err);\n                if (dir && pkg && opts.pathFilter) {\n                    var rfile = path.relative(dir, file);\n                    var rel = rfile.slice(0, rfile.length - exts[0].length);\n                    var r = opts.pathFilter(pkg, x, rel);\n                    if (r) return load(\n                        [''].concat(extensions.slice()),\n                        path.resolve(dir, r),\n                        pkg\n                    );\n                }\n                isFile(file, onex);\n            }\n            function onex(err, ex) {\n                if (err) return cb(err);\n                if (ex) return cb(null, file, pkg);\n                load(exts.slice(1), x, pkg);\n            }\n        }\n    }\n\n    function loadpkg(dir, cb) {\n        if (dir === '' || dir === '/') return cb(null);\n        if (process.platform === 'win32' && (/^\\w:[/\\\\]*$/).test(dir)) {\n            return cb(null);\n        }\n        if ((/[/\\\\]node_modules[/\\\\]*$/).test(dir)) return cb(null);\n\n        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {\n            if (unwrapErr) return loadpkg(path.dirname(dir), cb);\n            var pkgfile = path.join(pkgdir, 'package.json');\n            isFile(pkgfile, function (err, ex) {\n                // on err, ex is false\n                if (!ex) return loadpkg(path.dirname(dir), cb);\n\n                readPackage(readFile, pkgfile, function (err, pkgParam) {\n                    if (err) cb(err);\n\n                    var pkg = pkgParam;\n\n                    if (pkg && opts.packageFilter) {\n                        pkg = opts.packageFilter(pkg, pkgfile);\n                    }\n                    cb(null, pkg, dir);\n                });\n            });\n        });\n    }\n\n    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {\n        var cb = callback;\n        var fpkg = loadAsDirectoryPackage;\n        if (typeof fpkg === 'function') {\n            cb = fpkg;\n            fpkg = opts.package;\n        }\n\n        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {\n            if (unwrapErr) return cb(unwrapErr);\n            var pkgfile = path.join(pkgdir, 'package.json');\n            isFile(pkgfile, function (err, ex) {\n                if (err) return cb(err);\n                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);\n\n                readPackage(readFile, pkgfile, function (err, pkgParam) {\n                    if (err) return cb(err);\n\n                    var pkg = pkgParam;\n\n                    if (pkg && opts.packageFilter) {\n                        pkg = opts.packageFilter(pkg, pkgfile);\n                    }\n\n                    if (pkg && pkg.main) {\n                        if (typeof pkg.main !== 'string') {\n                            var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');\n                            mainError.code = 'INVALID_PACKAGE_MAIN';\n                            return cb(mainError);\n                        }\n                        if (pkg.main === '.' || pkg.main === './') {\n                            pkg.main = 'index';\n                        }\n                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {\n                            if (err) return cb(err);\n                            if (m) return cb(null, m, pkg);\n                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);\n\n                            var dir = path.resolve(x, pkg.main);\n                            loadAsDirectory(dir, pkg, function (err, n, pkg) {\n                                if (err) return cb(err);\n                                if (n) return cb(null, n, pkg);\n                                loadAsFile(path.join(x, 'index'), pkg, cb);\n                            });\n                        });\n                        return;\n                    }\n\n                    loadAsFile(path.join(x, '/index'), pkg, cb);\n                });\n            });\n        });\n    }\n\n    function processDirs(cb, dirs) {\n        if (dirs.length === 0) return cb(null, undefined);\n        var dir = dirs[0];\n\n        isDirectory(path.dirname(dir), isdir);\n\n        function isdir(err, isdir) {\n            if (err) return cb(err);\n            if (!isdir) return processDirs(cb, dirs.slice(1));\n            loadAsFile(dir, opts.package, onfile);\n        }\n\n        function onfile(err, m, pkg) {\n            if (err) return cb(err);\n            if (m) return cb(null, m, pkg);\n            loadAsDirectory(dir, opts.package, ondir);\n        }\n\n        function ondir(err, n, pkg) {\n            if (err) return cb(err);\n            if (n) return cb(null, n, pkg);\n            processDirs(cb, dirs.slice(1));\n        }\n    }\n    function loadNodeModules(x, start, cb) {\n        var thunk = function () { return getPackageCandidates(x, start, opts); };\n        processDirs(\n            cb,\n            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()\n        );\n    }\n};\n",
    "module.exports = function () {\n    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n    var origPrepareStackTrace = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) { return stack; };\n    var stack = (new Error()).stack;\n    Error.prepareStackTrace = origPrepareStackTrace;\n    return stack[2].getFileName();\n};\n",
    "var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];\n\nfunction specifierIncluded(specifier) {\n    var parts = specifier.split(' ');\n    var op = parts.length > 1 ? parts[0] : '=';\n    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');\n\n    for (var i = 0; i < 3; ++i) {\n        var cur = parseInt(current[i] || 0, 10);\n        var ver = parseInt(versionParts[i] || 0, 10);\n        if (cur === ver) {\n            continue; // eslint-disable-line no-restricted-syntax, no-continue\n        }\n        if (op === '<') {\n            return cur < ver;\n        } else if (op === '>=') {\n            return cur >= ver;\n        } else {\n            return false;\n        }\n    }\n    return op === '>=';\n}\n\nfunction matchesRange(range) {\n    var specifiers = range.split(/ ?&& ?/);\n    if (specifiers.length === 0) { return false; }\n    for (var i = 0; i < specifiers.length; ++i) {\n        if (!specifierIncluded(specifiers[i])) { return false; }\n    }\n    return true;\n}\n\nfunction versionIncluded(specifierValue) {\n    if (typeof specifierValue === 'boolean') { return specifierValue; }\n    if (specifierValue && typeof specifierValue === 'object') {\n        for (var i = 0; i < specifierValue.length; ++i) {\n            if (matchesRange(specifierValue[i])) { return true; }\n        }\n        return false;\n    }\n    return matchesRange(specifierValue);\n}\n\nvar data = require('./core.json');\n\nvar core = {};\nfor (var mod in data) { // eslint-disable-line no-restricted-syntax\n    if (Object.prototype.hasOwnProperty.call(data, mod)) {\n        core[mod] = versionIncluded(data[mod]);\n    }\n}\nmodule.exports = core;\n",
    "var isCoreModule = require('is-core-module');\n\nmodule.exports = function isCore(x) {\n    return isCoreModule(x);\n};\n",
    "var path = require('path');\nvar parse = path.parse || require('path-parse');\n\nvar getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {\n    var prefix = '/';\n    if ((/^([A-Za-z]:)/).test(absoluteStart)) {\n        prefix = '';\n    } else if ((/^\\\\\\\\/).test(absoluteStart)) {\n        prefix = '\\\\\\\\';\n    }\n\n    var paths = [absoluteStart];\n    var parsed = parse(absoluteStart);\n    while (parsed.dir !== paths[paths.length - 1]) {\n        paths.push(parsed.dir);\n        parsed = parse(parsed.dir);\n    }\n\n    return paths.reduce(function (dirs, aPath) {\n        return dirs.concat(modules.map(function (moduleDir) {\n            return path.resolve(prefix, aPath, moduleDir);\n        }));\n    }, []);\n};\n\nmodule.exports = function nodeModulesPaths(start, opts, request) {\n    var modules = opts && opts.moduleDirectory\n        ? [].concat(opts.moduleDirectory)\n        : ['node_modules'];\n\n    if (opts && typeof opts.paths === 'function') {\n        return opts.paths(\n            request,\n            start,\n            function () { return getNodeModulesDirs(start, modules); },\n            opts\n        );\n    }\n\n    var dirs = getNodeModulesDirs(start, modules);\n    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;\n};\n",
    "module.exports = function (x, opts) {\n    /**\n     * This file is purposefully a passthrough. It's expected that third-party\n     * environments will override it at runtime in order to inject special logic\n     * into `resolve` (by manipulating the options). One such example is the PnP\n     * code path in Yarn.\n     */\n\n    return opts || {};\n};\n",
    "var isCore = require('is-core-module');\nvar fs = require('fs');\nvar path = require('path');\nvar caller = require('./caller');\nvar nodeModulesPaths = require('./node-modules-paths');\nvar normalizeOptions = require('./normalize-options');\n\nvar realpathFS = fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;\n\nvar defaultIsFile = function isFile(file) {\n    try {\n        var stat = fs.statSync(file);\n    } catch (e) {\n        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;\n        throw e;\n    }\n    return stat.isFile() || stat.isFIFO();\n};\n\nvar defaultIsDir = function isDirectory(dir) {\n    try {\n        var stat = fs.statSync(dir);\n    } catch (e) {\n        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;\n        throw e;\n    }\n    return stat.isDirectory();\n};\n\nvar defaultRealpathSync = function realpathSync(x) {\n    try {\n        return realpathFS(x);\n    } catch (realpathErr) {\n        if (realpathErr.code !== 'ENOENT') {\n            throw realpathErr;\n        }\n    }\n    return x;\n};\n\nvar maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {\n    if (opts && opts.preserveSymlinks === false) {\n        return realpathSync(x);\n    }\n    return x;\n};\n\nvar defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {\n    var body = readFileSync(pkgfile);\n    try {\n        var pkg = JSON.parse(body);\n        return pkg;\n    } catch (jsonErr) {}\n};\n\nvar getPackageCandidates = function getPackageCandidates(x, start, opts) {\n    var dirs = nodeModulesPaths(start, opts, x);\n    for (var i = 0; i < dirs.length; i++) {\n        dirs[i] = path.join(dirs[i], x);\n    }\n    return dirs;\n};\n\nmodule.exports = function resolveSync(x, options) {\n    if (typeof x !== 'string') {\n        throw new TypeError('Path must be a string.');\n    }\n    var opts = normalizeOptions(x, options);\n\n    var isFile = opts.isFile || defaultIsFile;\n    var readFileSync = opts.readFileSync || fs.readFileSync;\n    var isDirectory = opts.isDirectory || defaultIsDir;\n    var realpathSync = opts.realpathSync || defaultRealpathSync;\n    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;\n    if (opts.readFileSync && opts.readPackageSync) {\n        throw new TypeError('`readFileSync` and `readPackageSync` are mutually exclusive.');\n    }\n    var packageIterator = opts.packageIterator;\n\n    var extensions = opts.extensions || ['.js'];\n    var includeCoreModules = opts.includeCoreModules !== false;\n    var basedir = opts.basedir || path.dirname(caller());\n    var parent = opts.filename || basedir;\n\n    opts.paths = opts.paths || [];\n\n    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory\n    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);\n\n    if ((/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/).test(x)) {\n        var res = path.resolve(absoluteStart, x);\n        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';\n        var m = loadAsFileSync(res) || loadAsDirectorySync(res);\n        if (m) return maybeRealpathSync(realpathSync, m, opts);\n    } else if (includeCoreModules && isCore(x)) {\n        return x;\n    } else {\n        var n = loadNodeModulesSync(x, absoluteStart);\n        if (n) return maybeRealpathSync(realpathSync, n, opts);\n    }\n\n    var err = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n\n    function loadAsFileSync(x) {\n        var pkg = loadpkg(path.dirname(x));\n\n        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {\n            var rfile = path.relative(pkg.dir, x);\n            var r = opts.pathFilter(pkg.pkg, x, rfile);\n            if (r) {\n                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign\n            }\n        }\n\n        if (isFile(x)) {\n            return x;\n        }\n\n        for (var i = 0; i < extensions.length; i++) {\n            var file = x + extensions[i];\n            if (isFile(file)) {\n                return file;\n            }\n        }\n    }\n\n    function loadpkg(dir) {\n        if (dir === '' || dir === '/') return;\n        if (process.platform === 'win32' && (/^\\w:[/\\\\]*$/).test(dir)) {\n            return;\n        }\n        if ((/[/\\\\]node_modules[/\\\\]*$/).test(dir)) return;\n\n        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');\n\n        if (!isFile(pkgfile)) {\n            return loadpkg(path.dirname(dir));\n        }\n\n        var pkg = readPackageSync(readFileSync, pkgfile);\n\n        if (pkg && opts.packageFilter) {\n            // v2 will pass pkgfile\n            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment\n        }\n\n        return { pkg: pkg, dir: dir };\n    }\n\n    function loadAsDirectorySync(x) {\n        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');\n        if (isFile(pkgfile)) {\n            try {\n                var pkg = readPackageSync(readFileSync, pkgfile);\n            } catch (e) {}\n\n            if (pkg && opts.packageFilter) {\n                // v2 will pass pkgfile\n                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment\n            }\n\n            if (pkg && pkg.main) {\n                if (typeof pkg.main !== 'string') {\n                    var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');\n                    mainError.code = 'INVALID_PACKAGE_MAIN';\n                    throw mainError;\n                }\n                if (pkg.main === '.' || pkg.main === './') {\n                    pkg.main = 'index';\n                }\n                try {\n                    var m = loadAsFileSync(path.resolve(x, pkg.main));\n                    if (m) return m;\n                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));\n                    if (n) return n;\n                } catch (e) {}\n            }\n        }\n\n        return loadAsFileSync(path.join(x, '/index'));\n    }\n\n    function loadNodeModulesSync(x, start) {\n        var thunk = function () { return getPackageCandidates(x, start, opts); };\n        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();\n\n        for (var i = 0; i < dirs.length; i++) {\n            var dir = dirs[i];\n            if (isDirectory(path.dirname(dir))) {\n                var m = loadAsFileSync(dir);\n                if (m) return m;\n                var n = loadAsDirectorySync(dir);\n                if (n) return n;\n            }\n        }\n    }\n};\n",
    "import {BeelderActionConfig} from \"./beelder\";\nimport BeelderScheme from \"./scheme\";\nimport BeelderReference from \"./reference\";\n\n\nexport default class BeelderAction {\n\n    static readonly actionName: string;\n    scheme: BeelderScheme;\n\n    constructor(config: BeelderActionConfig, scheme: BeelderScheme) {\n        this.scheme = scheme\n    }\n\n    public getDependencies(): string[] | null {\n        return null\n    }\n\n    public getTargets(): BeelderReference[] | null {\n        return null\n    }\n\n    public async run() {\n\n    }\n\n}",
    "\nimport util from 'util';\n\nexport default class AsyncEventEmitter {\n\n    private handlers: Map<string, Array<(...params: any[]) => any>>[]\n\n    public static PRIORITY_LOW = 3\n    public static PRIORITY_MONITOR = 2\n    public static PRIORITY_NORMAL = 1\n    public static PRIORITY_HIGH = 0\n\n    constructor() {\n        this.handlers = []\n    }\n\n    addListener(type: string, listener: () => void, priority: number)\n    {\n        let priorityBlock = this.handlers[priority]\n\n        if(!priorityBlock) {\n            priorityBlock = new Map()\n            this.handlers[priority] = priorityBlock\n        }\n\n        let handlers = priorityBlock.get(type)\n        if(handlers) {\n            handlers.push(listener)\n        } else {\n            priorityBlock.set(type, [listener])\n        }\n\n        this._emit('newListener', [type, listener]);\n    }\n\n    on(type: string, listener: (...params: any[]) => any, priority: number = AsyncEventEmitter.PRIORITY_NORMAL){\n        return this.addListener(type, listener, priority);\n    }\n\n    removeListener(type: string, listener: (...params: any[]) => any) {\n\n        for(let priorityBlock of this.handlers) {\n            if(!priorityBlock) continue\n            let handlers = priorityBlock.get(type)\n            if(!handlers) continue\n            let index = handlers.indexOf(listener)\n            if(index !== -1) {\n                handlers.splice(index, 1)\n            }\n        }\n    }\n\n    off(type: string, listener: (...params: any[]) => any) {\n        return this.removeListener(type, listener)\n    }\n\n    removeAllListeners(): void\n    removeAllListeners(type?: string): void {\n        if(type) {\n            for (let priorityBlock of this.handlers) {\n                if (type && priorityBlock) {\n                    priorityBlock.delete(type)\n                }\n            }\n        } else {\n            this.handlers = []\n        }\n    }\n\n\n    once(type: string, listener: (...params: any[]) => any) {\n        const on = () => {\n            this.removeListener(type, on);\n            return listener.apply(this, arguments);\n        }\n        return this.on(type, on);\n    }\n\n    async _emit(type: string, args?: any[]) {\n        let result = true;\n\n        for(let priorityBlock of this.handlers) {\n            if(!priorityBlock) continue\n            let handlers = priorityBlock.get(type)\n            if(!handlers) continue\n            for(let handler of handlers) {\n                if(util.types.isAsyncFunction(handler)) {\n                    if ((await handler.apply(this, args)) === false) {\n                        result = false;\n                    }\n                } else {\n                    if (handler.apply(this, args) === false) {\n                        result = false;\n                    }\n                }\n            }\n        }\n\n        return result\n    }\n\n    async emit(type: string, ...values: any[]) {\n        let args = Array.prototype.slice.call(arguments, 1)\n        let params = Array.prototype.slice.call(arguments)\n\n        await this._emit('event', params);\n\n        return (await this._emit(type, args)) !== false;\n    }\n}",
    "\nimport Action from \"./action\";\nimport {BeelderActionConfig} from \"./beelder\";\nimport BeelderScheme from \"./scheme\";\nimport BeelderReference from \"./reference\";\nimport BuildCache from \"./build-cache\";\n\nexport interface BaseActionConfig extends BeelderActionConfig {\n    source: string\n    target: string\n}\n\nexport default class BaseAction extends Action {\n\n    target: BeelderReference;\n    source: BeelderReference;\n    cache: BuildCache;\n\n    constructor(config: BaseActionConfig, scheme: BeelderScheme) {\n        super(config, scheme);\n\n        this.target = new BeelderReference(config.target)\n        this.source = new BeelderReference(config.source)\n        this.cache = scheme.beelder.cache.getSection((this.constructor as typeof BaseAction).actionName)\n    }\n\n    getDependencies(): string[] | null {\n        if(this.source.isDependency) {\n            return [this.source.getDependency()]\n        }\n        return null\n    }\n\n    getTargets(): BeelderReference[] | null {\n        if(this.target.definesTarget) {\n            return [this.target]\n        }\n        return null\n    }\n}",
    "import BeelderScheme, {BeelderSchemeConfig} from \"./scheme\";\nimport BundleJavascriptAction from \"./schemes/bundle-javascript\";\nimport CopyAction from \"./schemes/copy\";\nimport TextureAtlasAction from \"./schemes/texture-atlas\";\nimport BeelderAction from \"./action\";\nimport Timings from \"./timings\";\nimport BeelderReference from \"./reference\";\nimport path from \"path\";\nimport Chalk from \"chalk\"\nimport BuildCache from \"./build-cache\";\nimport CreateShaderLibraryAction from \"./schemes/create-shader-library\";\nimport CompileSCSSSchemeAction from \"./schemes/compile-scss\";\nimport DeleteAction from \"./schemes/delete\";\nimport RunCommandAction from \"./schemes/run-command\";\nimport RequireTargetAction from \"./schemes/require-target\";\n\nexport interface BeelderActionConfig {\n    action: string\n}\n\nexport interface BeelderConfig {\n    cacheDirectory?: string;\n    schemes: { [key: string]: BeelderSchemeConfig }\n}\n\nexport default class Beelder {\n\n    private config: BeelderConfig\n    public static actions: Map<string, typeof BeelderAction> = new Map()\n    public schemes: Map<string, BeelderScheme>\n    public targetMap: Map<string, BeelderScheme>\n    public referenceMap: Map<string, BeelderReference>\n    public projectRoot: string;\n    public cacheDirectory: string;\n    public cache: BuildCache;\n\n    constructor(config: BeelderConfig, projectRoot?: string) {\n        this.config = config\n        this.projectRoot = projectRoot ?? '/'\n        this.cacheDirectory = path.resolve(this.projectRoot, this.config.cacheDirectory ?? \"beelder-cache\")\n        this.cache = new BuildCache(this.cacheDirectory)\n    }\n\n    loadSchemes(): void {\n        Timings.begin(\"Initializing Beelder\")\n        this.schemes = new Map()\n        this.targetMap = new Map()\n        this.referenceMap = new Map()\n\n        for(let [name, scheme] of Object.entries(this.config.schemes)) {\n            this.schemes.set(name, new BeelderScheme(name, scheme, this))\n        }\n        for(let scheme of this.schemes.values()) {\n            for(let target of scheme.getTargets()) {\n                this.targetMap.set(target.getDefinedTarget(), scheme)\n                this.referenceMap.set(target.getDefinedTarget(), target);\n            }\n        }\n        Timings.end()\n    }\n\n    static registerAction(actionClass: typeof BeelderAction) {\n        this.actions.set(actionClass.actionName, actionClass);\n    }\n\n    async runScheme(schemeName: string) {\n        if(!this.schemes) this.loadSchemes()\n        let scheme = this.schemes.get(schemeName)\n        if (!scheme) throw new Error(\"No such scheme: '\" + schemeName + \"'\")\n\n        let state = Timings.getStackState()\n        try {\n\n            Timings.begin(\"Building\")\n\n            let list: BeelderScheme[] = []\n            let stack: BeelderScheme[] = []\n\n            this.enqueueScheme(list, scheme, stack)\n            await this.runSchemeList(list)\n\n            Timings.end(\"Build finished\")\n\n        } catch(e) {\n            console.error(e)\n            Timings.setStackState(state, \"%s \" + Chalk.red(\"failed due to error\"))\n            throw e\n        }\n    }\n\n    private enqueueScheme(list: BeelderScheme[], scheme: BeelderScheme, stack: BeelderScheme[]) {\n\n        if(list.indexOf(scheme) != -1) return\n\n        let dependencies = scheme.getDependencies()\n\n        if(stack.indexOf(scheme) != -1) {\n            let arrow = \" -> \"\n            let path = stack.slice(stack.indexOf(scheme)).map(a => a.name).join(arrow)\n            throw new Error(\"Cycle dependency: \" + path + arrow + scheme.name);\n        }\n\n        stack.push(scheme)\n\n        for(let dependencyName of dependencies) {\n            let dependency = this.targetMap.get(dependencyName)\n            if(!dependency) throw new Error(\"Scheme '\" + scheme.name + \"' have an unknown dependency: '\" + dependencyName + \"'\")\n            this.enqueueScheme(list, dependency, stack)\n        }\n\n        stack.pop()\n        list.push(scheme)\n    }\n\n    private async runSchemeList(list: BeelderScheme[]) {\n        for(let scheme of list) {\n            await scheme.run()\n        }\n    }\n\n    public resolveReference(reference: BeelderReference) {\n        let referencePath: string\n\n        if(reference.isDependency) {\n            let dependency = reference.getDependency()\n\n            let beelderReference = this.referenceMap.get(dependency)\n            if(!beelderReference) throw new Error(\"Failed to resolve reference: '\" + dependency + \"'\")\n\n            referencePath = beelderReference.getPath()\n        } else {\n            referencePath = reference.getPath()\n        }\n\n        if(!referencePath) return null\n\n        referencePath = path.join(this.projectRoot, referencePath)\n\n        return referencePath\n    }\n\n    getAbsolutePath(file: string) {\n        return path.join(this.projectRoot, file)\n    }\n}\n\nBeelder.registerAction(BundleJavascriptAction)\nBeelder.registerAction(CopyAction)\nBeelder.registerAction(TextureAtlasAction)\nBeelder.registerAction(CreateShaderLibraryAction)\nBeelder.registerAction(CompileSCSSSchemeAction)\nBeelder.registerAction(DeleteAction)\nBeelder.registerAction(RequireTargetAction)",
    "import {prepareFileLocation} from \"./utils\";\nimport fs from \"fs\"\nimport path from \"path\";\n\nexport type FileListCache = { [key: string]: {\n    modificationDate: number,\n    data?: any\n} | null}\n\nexport default class BuildCache {\n    sectionPath: string;\n    cacheFilePath: any;\n\n    constructor(sectionPath: string) {\n        this.sectionPath = sectionPath\n        this.cacheFilePath = path.join(this.sectionPath, \"section.json\")\n    }\n\n    getSection(section: string): BuildCache {\n        let sectionPath = path.join(this.sectionPath, section)\n\n        return new BuildCache(sectionPath)\n    }\n\n    getJSON() {\n        if (!prepareFileLocation(this.cacheFilePath)) {\n            throw new Error(\"Could not create cache file\");\n        }\n\n        try {\n            let text = fs.readFileSync(this.cacheFilePath, \"utf-8\")\n            return JSON.parse(text)\n        } catch(error) {\n            if(error.code != \"ENOENT\") {\n                console.error(\"Cache file is corrupted, clearing the cache\")\n            }\n            fs.writeFileSync(this.cacheFilePath, \"{}\")\n            return {}\n        }\n    }\n\n    setJSON(json: any) {\n        if (!prepareFileLocation(this.cacheFilePath)) {\n            throw new Error(\"Could not create cache file\");\n        }\n\n        try {\n            let data = JSON.stringify(json)\n            fs.writeFileSync(this.cacheFilePath, data, \"utf8\")\n        } catch(error) {\n            console.error(\"Could not save cache file for section \" + this.sectionPath);\n            console.error(error.message)\n        }\n    }\n\n    static fileRequiresRefresh(cache: FileListCache, fileName: string): boolean {\n        let cacheEntry = cache[fileName];\n\n        if(!cacheEntry) return true\n\n        try { fs.accessSync(fileName) }\n        catch(error) { return true }\n\n        let stats = fs.statSync(fileName)\n\n        return cacheEntry.modificationDate < stats.mtime.getTime()\n    }\n\n    static getFileData(cache: FileListCache, fileName: string): any {\n        let cacheEntry = cache[fileName]\n        if(!cacheEntry) return null\n        return cacheEntry.data\n    }\n\n    static refreshFileData(cache: FileListCache, fileName: string): void\n    static refreshFileData(cache: FileListCache, fileName: string, data: any): void\n    static refreshFileData(cache: FileListCache, fileName: string, data?: any) {\n        let cacheEntry = cache[fileName]\n        if (cacheEntry) {\n            cacheEntry.modificationDate = Date.now()\n            cacheEntry.data = data\n        } else {\n            cache[fileName] = {\n                modificationDate: Date.now(),\n                data: data\n            }\n        }\n    }\n}\n",
    "\nimport util from 'util';\n\nexport interface EventHandlerTarget {\n    on(type: string, listener: (...params: any[]) => any): void\n    off(type: string, listener: (...params: any[]) => any): void\n}\n\nexport default class EventHandlerBlock {\n    public listeners = new Map<string, (() => void)[]>();\n    public target: EventHandlerTarget\n\n    constructor() {\n\n    }\n\n    bind(event: string, handler: (event: Event) => void) {\n        if(this.listeners.has(event)) {\n            this.unbind(event)\n        }\n        const self = this\n        let listener = null\n\n        if(util.types.isAsyncFunction(handler)) {\n            listener = async function () {\n                await handler.apply(self, arguments)\n            }\n        } else {\n            listener = function () {\n                handler.apply(self, arguments)\n            }\n        }\n\n        if(this.listeners.has(event)) {\n            this.listeners.get(event).push(listener)\n        } else {\n            this.listeners.set(event, [listener])\n        }\n\n        if(this.target) this.target.on(event, listener)\n    }\n\n    unbind(event: string) {\n        if(!this.target) return\n\n        if(this.target) {\n            for(let listener of this.listeners.get(event)) {\n                this.target.off(event, listener)\n            }\n        }\n        this.listeners.delete(event)\n    }\n\n    private unbindTarget(target: EventHandlerTarget) {\n        for(let [key, listeners] of this.listeners.entries()) {\n            for(let listener of listeners) {\n                target.off(key, listener)\n            }\n        }\n    }\n\n    private bindTarget(target: EventHandlerTarget) {\n        for(let [key, listeners] of this.listeners.entries()) {\n            for(let listener of listeners) {\n                target.on(key, listener)\n            }\n        }\n    }\n\n    setTarget(target: EventHandlerTarget) {\n        if(this.target) this.unbindTarget(this.target)\n        if(target) this.bindTarget(target)\n    }\n}",
    "import BundlerPlugin, { BundlerPluginConfig } from \"./bundler-plugin\";\nimport BasePlugin from \"./plugins/base\";\nimport ResourcePlugin from \"./plugins/resource-plugin\";\nimport JSONCommentReplacerBundlerPlugin from \"./plugins/json-comment-replacer\";\n\nexport default class BundlerPluginFactory {\n\n    static plugins: Map<string, typeof BundlerPlugin> = new Map();\n\n    static register(plugin: typeof BundlerPlugin) {\n        this.plugins.set(plugin.getPluginName(), plugin);\n    }\n\n    static getPlugin(config: BundlerPluginConfig) {\n        const Plugin = this.plugins.get(config.plugin);\n\n        if(!Plugin) return null;\n        return new Plugin(config);\n    }\n}\n\nBundlerPluginFactory.register(JSONCommentReplacerBundlerPlugin)\nBundlerPluginFactory.register(BasePlugin)\nBundlerPluginFactory.register(ResourcePlugin)",
    "import Bundler from \"./bundler\";\nimport EventEmitter from \"events\";\nimport BeelderReference from \"../reference\";\n\nexport interface BundlerPluginConfig {\n    plugin: string\n}\n\n/**\n * A base bundler plugin class.\n * The builder plugin can traverse the project\n * tree and modify it during build. See native\n * builder plugins for examples.\n *\n * Bundler plugin **should** handle cases when\n * it's called in the same build scheme with\n * different options within a single build\n * procedure. I.e, it should not cache its\n * results if they can be influenced with\n * plugin/scheme input options.\n *\n * To store file-related data, PackerFileCache\n * interface should be inherited, so you may\n * store your data in your custom fields. Be\n * sure to use unique field names. (i.e, you\n * may prefix them with your plugin identifier)\n */\nexport default class BundlerPlugin extends EventEmitter {\n\n    public bundler?: Bundler = null\n\n    constructor(config: BundlerPluginConfig) {\n        super()\n    }\n\n    setCompiler(bundler: Bundler) {\n        this.bundler = bundler\n    }\n\n\n    /* TODO: As babelPlugins may not change\n        from build to build, maybe it's better\n        to make this method static. */\n\n    /**\n     * Babel plugins which are required to run before build.\n     * Please, note that this method should ensure that it\n     * will return the same babel plugins with the same\n     * options, as long as the scheme configuration\n     * is not changed.\n     *\n     * The reason for this restriction is that because\n     * of the build cache, the files are not re-transformed\n     * through babel unless they got changed. Beelder will\n     * not detect if your babel plugin config has been\n     * changed.\n     */\n    getBabelPlugins(): any[] | null {\n        return null\n    }\n\n    static getPluginName(): string {\n        return \"invalid\"\n    }\n\n    /**\n     * Returns targets that should be built before this plugin runs\n     */\n    public getDependencies(): string[] | null {\n        return []\n    }\n\n    /**\n     * Returns targets that this plugin exposes\n     */\n    public getTargets(): BeelderReference[] | null {\n        return []\n    }\n}",
    "import BundlerPlugin from \"./bundler-plugin\"\n// @ts-ignore\nimport incremental from \"browserify-incremental\"\nimport exorcist from \"exorcist\"\nimport {concatOptionalArrays, prepareFileLocation} from \"../utils\";\nimport * as fs from \"fs\";\nimport {BundlerPluginConfig} from \"./bundler-plugin\";\nimport BundlerPluginFactory from \"./bundler-plugin-factory\";\nimport BundleJavascriptAction from \"../schemes/bundle-javascript\"\nimport BuildCache from \"../build-cache\";\nimport Packer, { PackerBundleFileInfo } from \"./packer/packer\";\nimport { Timings } from \"..\";\nimport BeelderReference from \"../reference\";\nimport BeelderScheme from \"../scheme\";\nimport {Readable} from \"stream\";\nimport browserPack from \"browser-pack\";\nimport PackerProjectStorage from \"./packer/packer-project-storage\";\n\nexport interface BundlerConfig {\n    scheme: BeelderScheme\n\n    source: string;\n    destination: string;\n    projectRoot: string;\n\n    babelPlugins?: any[]\n    babelPresets?: any;\n    babelSourceType?: \"script\" | \"module\";\n    generateSourceMaps?: boolean;\n    debug?: boolean;\n    cache: BuildCache;\n    externalLibraries?: string[];\n\n    plugins?: BundlerPluginConfig[]\n    buildAction?: BundleJavascriptAction\n    extensions?: string[]\n    includeExternalModules?: boolean | string[]\n}\n\n/**\n * A class that generalises TypeScript compilation.\n */\n\nexport default class Bundler {\n    public readonly config: BundlerConfig;\n    public plugins: BundlerPlugin[] = [];\n    packer: Packer\n    scheme: BeelderScheme;\n\n    // Cache files should not me modified by\n    // anyone else, so we can avoid file modification\n    // date check. It would even break everything\n    buildTargetDataStorage: PackerProjectStorage\n\n    constructor(config: BundlerConfig) {\n        this.config = config\n\n        if(!this.config.extensions) this.config.extensions = [\".js\", \".ts\", \".json\"]\n        if(!this.config.babelSourceType) this.config.babelSourceType = \"module\"\n        if(!this.config.babelPresets) this.config.babelPresets = this.getDefaultBabelifyPresets()\n\n        let cacheSection = this.config.cache.getSection(\"target-metadata\")\n        this.buildTargetDataStorage = new PackerProjectStorage(cacheSection, {\n            skipFileModificationDateCheck: true\n        })\n\n        this.scheme = config.scheme\n        this.packer = this.createPacker()\n        this.loadPlugins()\n    }\n\n    loadPlugins(): void {\n        if(!this.config.plugins) return;\n\n        for(let pluginConfig of this.config.plugins) {\n            let plugin = BundlerPluginFactory.getPlugin(pluginConfig)\n            if(!plugin) throw new Error(\"Plugin not found: \" + pluginConfig.plugin)\n            this.plugins.push(plugin)\n            plugin.setCompiler(this)\n        }\n    }\n\n    private createPacker(): Packer {\n        return new Packer(this, {\n            babelTransformConfig: {\n                plugins: this.getBabelPluginList(),\n                presets: this.config.babelPresets,\n                sourceMaps: this.config.generateSourceMaps,\n                sourceType: this.config.babelSourceType,\n            },\n            extensions: this.config.extensions,\n            includeExternalModules: this.config.includeExternalModules\n        })\n    }\n\n    private getDefaultBabelifyPresets() {\n        return [\n            ['@babel/preset-env', {\n                \"debug\": this.config.debug,\n                \"targets\": \"node 7\"\n            }]\n        ]\n    }\n\n    async build() {\n\n        let projectUpdated = await this.packer.rebuildSubtree(this.config.source)\n\n        if(this.config.destination) {\n            let entries = await this.packer.bundleSubtree(this.config.source)\n            if(!entries) return\n\n            if(!this.bundleFilesUpdated(entries) && !projectUpdated) return\n\n            Timings.begin(\"Collapsing module identifiers\")\n            Packer.collapseBundleIDs(entries)\n            Timings.end()\n\n            //fs.writeFileSync(\"./beelder-debug-\" + Math.floor(Math.random() * 1000) + \".json\", JSON.stringify(entries))\n\n            Timings.begin(\"Writing bundle\")\n            let stream = Readable.from(entries).pipe(browserPack({ raw: true }))\n            await this.listen(stream)\n            Timings.end()\n        } else if(!projectUpdated) return\n\n        Timings.begin(\"Saving cache\")\n        await this.packer.cache.saveCaches()\n        Timings.end()\n    }\n\n    private bundleFilesUpdated(entries: PackerBundleFileInfo[]) {\n        let result = false\n        let cache = this.buildTargetDataStorage.accessFileData(this.config.destination)\n\n        if(!cache.bundleFiles) {\n            cache.bundleFiles = {}\n            result = true\n        }\n\n        for(let entry of entries) {\n            let globalPath = entry.globalPath\n            let rebuildDate = this.packer.getFile(globalPath).getRebuildDate()\n            let fileInfo = cache.bundleFiles[globalPath]\n\n            if(!fileInfo) {\n                cache.bundleFiles[globalPath] = { modificationDate: rebuildDate }\n                result = true\n                continue;\n            }\n\n            if(rebuildDate > fileInfo.modificationDate) {\n                fileInfo.modificationDate = rebuildDate\n                result = true\n            }\n        }\n\n        if(result) {\n            this.buildTargetDataStorage.writeFileData(this.config.destination, cache)\n            this.buildTargetDataStorage.save()\n        }\n\n        return result\n    }\n\n    private getBabelPluginList(): any[] {\n\n        // Default plugin list\n        let result: any[] = [\n            [\"@babel/plugin-syntax-class-properties\"],\n            [\"@babel/plugin-proposal-class-properties\", { loose: true }],\n            [\"@babel/plugin-transform-typescript\"],\n            [\"@babel/plugin-transform-runtime\"],\n        ]\n\n        result = concatOptionalArrays(result, this.config.babelPlugins)\n\n        for (let plugin of this.plugins) {\n            let babelPlugins = plugin.getBabelPlugins()\n            if (babelPlugins) result = result.concat(babelPlugins)\n        }\n\n        return result;\n    }\n\n    private listen(stream: NodeJS.ReadableStream): Promise<boolean> {\n        return new Promise<boolean>((resolve) => {\n\n            let errorHandler = (error: any) => {\n                console.error(error.message)\n                if(error.annotated) console.error(error.annotated)\n                resolve(true)\n            }\n\n            if(!prepareFileLocation(this.config.destination)) {\n                errorHandler(new Error(\"Cannot create parent directories for '\" + this.config.destination + \"'\"))\n            } else {\n                stream.on(\"error\", errorHandler)\n                stream = stream.pipe(this.getExorcist())\n                stream.on(\"error\", errorHandler)\n                let writeStream = fs.createWriteStream(this.config.destination)\n                stream.pipe(writeStream)\n                writeStream.on(\"error\", errorHandler)\n                writeStream.on(\"close\", resolve)\n            }\n        })\n    }\n\n    private getExorcist() {\n        return exorcist(\n            this.config.destination + \".map\",\n            null,\n            this.config.projectRoot,\n            this.config.projectRoot\n        )\n    }\n\n    getTargets(): BeelderReference[] | null {\n        let result: BeelderReference[] | null = null\n\n        for(let plugin of this.plugins) {\n            result = concatOptionalArrays(result, plugin.getTargets())\n        }\n\n        return result\n    }\n\n    getDependencies(): string[] | null {\n        let result: string[] | null = null\n\n        for(let plugin of this.plugins) {\n            result = concatOptionalArrays(result, plugin.getDependencies())\n        }\n\n        return result\n    }\n}",
    "import * as babel from \"@babel/core\";\nimport path from \"path\";\nimport traverse from \"@babel/traverse\";\nimport Packer from \"./packer\";\nimport BrowserResolve from 'browser-resolve'\n\ninterface SourcePosition {\n    line: number;\n    column: number;\n}\n\ninterface PackerASTWatcherConfig {\n    extensions: string[]\n    packer: Packer\n}\n\nexport default class PackerASTWatcher {\n    config: PackerASTWatcherConfig;\n\n    constructor(config: PackerASTWatcherConfig) {\n        this.config = config\n    }\n\n    private getErrorWithMessage(message: string, filePath: string, location: SourcePosition) {\n        let relativePath = path.relative(this.config.packer.bundler.config.projectRoot, filePath)\n        if(location) {\n            return new Error(message + \" at \" + relativePath + \":\" + location.line)\n        } else {\n            return new Error(message + \" at \" + relativePath)\n        }\n    }\n\n    private guessFilePath(dependency: string, filePath: string): string {\n        return BrowserResolve.sync(dependency, {\n            filename: filePath,\n            extensions: this.config.extensions\n        })\n    }\n\n    findDependencies(ast: babel.types.File | babel.types.Program, filePath: string) {\n        let dependencies: { [key: string]: string } = {}\n\n        const addDependency = (dependency: string, node: babel.types.Node) => {\n            if(this.config.packer.shouldWalkFile(dependency)) {\n                try {\n                    dependencies[dependency] = this.guessFilePath(dependency, filePath)\n                } catch (e) {\n                    throw this.getErrorWithMessage(\"No such file: \" + dependency, filePath, node.loc && node.loc.start)\n                }\n            } else {\n                dependencies[dependency] = dependency\n            }\n        }\n\n        traverse(ast, {\n            CallExpression: (nodePath) => {\n                let callee = nodePath.node.callee\n                if(callee.type != \"Identifier\" || callee.name != \"require\") return\n                let args = nodePath.node.arguments\n                if(args.length != 1 || args[0].type != \"StringLiteral\") return\n                addDependency(args[0].value, nodePath.node)\n            },\n            ImportDeclaration: (nodePath) => {\n                let source = nodePath.node.source.value\n                addDependency(source, nodePath.node)\n            }\n        })\n\n        return dependencies\n    }\n}",
    "import PackerProjectStorage from \"./packer-project-storage\";\nimport PackerFileStorage from \"./packer-file-storage\";\nimport BuildCache from \"../../build-cache\";\n\nexport default class PackerCache {\n    /**\n     * Storage that should be used for storing data\n     * that may not be left unattended on each build.\n     * Large amounts of data will make this storage\n     * slow to read and write.\n     */\n    fastStorage: PackerProjectStorage\n\n    /**\n     * Storage that should be used for storing\n     * large amounts of data that you won't read\n     * at each build.\n     */\n    largeStorage: PackerFileStorage\n\n    /**\n     * Storage for caching abstract syntax trees\n     */\n    astStorage: PackerFileStorage\n\n    constructor(cache: BuildCache) {\n\n        this.fastStorage = new PackerProjectStorage(cache.getSection(\"fast-storage\"))\n        this.largeStorage = new PackerFileStorage(cache.getSection(\"large-storage\"))\n        this.astStorage = new PackerFileStorage(cache.getSection(\"ast-storage\"))\n    }\n\n    async saveCaches() {\n        await this.fastStorage.save()\n        // await this.largeStorage.save() - This will do nothing\n        // await this.astStorage.save() - And this too. AST storage also will only be saved when file is rebuilt\n    }\n}",
    "import PackerStorage from \"./packer-storage\";\nimport {hashToUUIDString32, murmurhash3_32_gc} from \"../../utils\";\nimport BuildCache from \"../../build-cache\";\n\nexport default class PackerFileStorage extends PackerStorage {\n\n    getFileNameHash(fileName: string): number {\n        return murmurhash3_32_gc(fileName, 0xBEEF);\n    }\n\n    private getSection(filePath: string) {\n        let hash = this.getFileNameHash(filePath)\n        let hashString = hashToUUIDString32(hash)\n\n        return this.cache.getSection(hashString)\n    }\n\n    accessFileData(filePath: string) {\n        let section = this.getSection(filePath).getJSON()\n        if(!section.files) section.files = {}\n\n        if(BuildCache.fileRequiresRefresh(section.files, filePath)) {\n            return {}\n        }\n\n        return BuildCache.getFileData(section.files, filePath)\n    }\n\n    save() {\n\n    }\n\n    writeFileData(filePath: string, data: any) {\n        let section = this.getSection(filePath)\n        let json = section.getJSON()\n        if(!json.files) json.files = {}\n\n        BuildCache.refreshFileData(json.files, filePath, data)\n        section.setJSON(json)\n    }\n}",
    "import Packer from \"./packer\";\nimport fs from \"fs\"\nimport path from \"path\";\n\n//\n// To clarify:\n//\n// There will be two types of permanent data buffers: per-file and per-project.\n//\n// The more effective way to store light data that we will have to access at least\n// once per build is to store it on the per-project storage.\n//\n// The most effective way to store heavy data is per-file storage,\n// especially if we won't always need it.\n//\n// The dependency tree should be stored in per-project storage since it's the first\n// thing that should be analyzed when project is building\n//\n// Since bundler plugin may not change AST tree cache, it's necessary to\n// save its original version. AST tree is heavy to store in memory and parse,\n// but we won't always want to read it. (only when file has been modified or\n// will be processed by some plugin)\n//\n// Even thou transformed code is huge, the file that stores it will not be much larger\n// than the bundle file, and it's three times lighter than AST in average, so we will\n// store it in per-project storage.\n//\n\n/**\n * Interface for accessing file cache and metadata\n */\nexport default class PackerFile {\n    public readonly filePath: string\n    public readonly fastStorage: any\n    public readonly projectPath: string\n    public readonly packer: Packer;\n    private ast: babel.types.File\n    shouldBeCompiled: boolean;\n    isJSON: boolean;\n    inOriginalPackage: boolean;\n\n    constructor(packer: Packer, filePath: string) {\n        this.packer = packer\n        this.filePath = filePath\n        this.projectPath = path.relative(this.packer.bundler.config.projectRoot, filePath)\n        this.fastStorage = this.packer.cache.fastStorage.accessFileData(this.filePath)\n\n        // TODO: make this more smart\n        let extension = path.extname(this.projectPath)\n        this.shouldBeCompiled = extension == \".ts\" || extension == \".js\"\n        this.inOriginalPackage = !this.projectPath.startsWith(\"..\") && this.projectPath.indexOf(\"node_modules\") == -1\n        this.isJSON = extension == \".json\"\n    }\n\n    /**\n     * Fetch file dependencies with most efficient available way\n     *\n     * - **Fast case**: File dependencies has already been found\n     * in a previous build. If file has not been modified,\n     * cached version will be returned. This way, no requests to\n     * the file system will be made.\n     *\n     * - **Slow case**: ache is outdated or missing. The file will\n     * be rebuilt and its dependencies will be retrieved from\n     * its AST. Two requests to the file system will be made:\n     * one to read file contents and another one to write the AST\n     * cache.\n     * <br/>\n     * **File system calls**:\n     * <table width=\"200\">\n     *     <tr><td>Average case:</td><td>0 requests</td></tr>\n     *     <tr><td>Worst case:</td><td>2 requests</td></tr>\n     * </table>\n     *\n     */\n    getDependencies(): { [key: string]: string } {\n        if (!this.fastStorage.dependencies) {\n            this.fastStorage.dependencies = this.determineDependencies()\n        }\n\n        return this.fastStorage.dependencies\n    }\n\n    /**\n     * Returns file text contents\n     */\n    getContents(): string {\n        return fs.readFileSync(this.filePath, \"utf8\")\n    }\n\n    private compile(): babel.types.File {\n        let contents = this.getContents()\n\n        if(this.shouldBeCompiled) {\n            if(this.inOriginalPackage) {\n                return this.packer.transformFile(contents, this.projectPath).ast\n            } else {\n                return this.packer.parseFile(contents, this.projectPath)\n            }\n        } else {\n            return null\n        }\n    }\n\n    /**\n     * Fetch AST tree for this file after babel-transformed file\n     * with most efficient available way\n     *\n     * **Please note** that this method is likely to be **slow**.\n     * Reading the AST for each file can make the build process\n     * slow.\n     *\n     * - **Fastest case**: If file AST tree has been already loaded,\n     * it will just be returned. No file system requests will be made.\n     *\n     * - **Fast case**: Most common case for incremental rebuild,\n     * when AST tree has been created in a previous build and file\n     * cache is up to date. To read AST cache, a single request to\n     * the file system will be made\n     *\n     * - **Slow case**: Cache is outdated or missing. The file will\n     * be rebuilt and its dependencies will be retrieved from\n     * its AST. Two requests to the file system will be made:\n     * one to read file contents and another one to write the AST\n     * cache.\n     * <br/>\n     * **File system calls**:\n     * <table width=\"200\">\n     *     <tr><td>Best case:</td><td>0 requests</td></tr>\n     *     <tr><td>Average case:</td><td>1 request</td></tr>\n     *     <tr><td>Worst case:</td><td>2 requests</td></tr>\n     * </table>\n     *\n     * @returns: AST tree of babel-transformed file\n     */\n    getAST(ignoreCache: boolean = false): babel.types.File {\n        if(!ignoreCache) {\n            if (this.ast) return this.ast\n            this.ast = this.packer.cache.astStorage.accessFileData(this.filePath)\n\n            // accessFileData returns empty object\n            // if entry was not found, so we have\n            // to check if we've got a valid AST\n            // tree from cache.\n            if (this.ast && this.ast.type) return this.ast\n        }\n        this.ast = this.compile()\n        this.packer.cache.astStorage.writeFileData(this.filePath, this.ast)\n\n        return this.ast\n    }\n\n    /**\n     * Generated code after babel and plugin transformations.\n    *\n     * **Please note** that this method should not be called\n     * from plugins, as it will cause packer to ignore following\n     * AST transformations.\n     *\n     * - **Fastest case**: If code has been already generated in\n     * a previous build, a cached version will be returned.\n     * As the code cache is stored in a fast storage, no\n     * file system requests will be made\n     *\n     * - **Fast case**: If code cache was cleared by some plugin,\n     * but AST cache is up-to-date, code will be regenerated from\n     * this tree without rebuilding the file.\n     */\n    getTransformedCode() {\n        if(this.fastStorage.code) return this.fastStorage.code\n\n        if(this.shouldBeCompiled) {\n            this.fastStorage.code = this.packer.generateCode(this.getAST(), this.projectPath, this.getContents())\n        } else if(this.isJSON) {\n            this.fastStorage.code = \"module.exports = \" + this.getContents()\n        } else {\n            this.fastStorage.code = this.getContents()\n        }\n\n        this.fastStorage.rebuildDate = Date.now()\n\n        return this.fastStorage.code\n    }\n\n    /**\n     * Clears transformed code cache. Plugins should call this method\n     * for each file they transform.\n     */\n    clearCodeCache() {\n        this.fastStorage.code = null\n        this.fastStorage.rebuildDate = 0\n    }\n\n    private determineDependencies(): { [key: string]: string } {\n        // Ignoring cache here to avoid unnecessary querying\n        // of the file system. This method is called only\n        // when cache is outdated or missing.\n        let ast = this.getAST(true)\n        if(!ast) return {}\n        return this.packer.astWatcher.findDependencies(ast, this.filePath)\n    }\n\n    getFastPluginStorage(plugin: string) {\n        if(!this.fastStorage.pluginData) {\n            this.fastStorage.pluginData = {}\n        }\n\n        let pluginData = this.fastStorage.pluginData[plugin]\n\n        if(!pluginData) {\n            pluginData = {}\n            this.fastStorage.pluginData[plugin] = pluginData\n        }\n        return pluginData;\n    }\n\n    cacheIsUpToDate() {\n        return !!this.fastStorage.dependencies\n    }\n\n    getRebuildDate() {\n        return this.fastStorage.rebuildDate || 0\n    }\n}",
    "import PackerStorage from \"./packer-storage\";\nimport {hashToUUIDString32} from \"../../utils\";\nimport BuildCache from \"../../build-cache\";\n\nexport interface PackerProjectStorageConfig {\n    skipFileModificationDateCheck?: boolean\n}\n\nexport default class PackerProjectStorage extends PackerStorage {\n\n    private cachedJSON: any = null\n    config: PackerProjectStorageConfig\n\n    constructor(cache: BuildCache, config: PackerProjectStorageConfig = {}) {\n        super(cache);\n        this.config = config\n    }\n\n    private getSection() {\n        if(this.cachedJSON) return this.cachedJSON\n\n        this.cachedJSON = this.cache.getJSON()\n        if(!this.cachedJSON.files) this.cachedJSON.files = {}\n        return this.cachedJSON\n    }\n\n    accessFileData(filePath: string) {\n        let section = this.getSection()\n\n        let data = null\n\n        if(this.config.skipFileModificationDateCheck || !BuildCache.fileRequiresRefresh(section.files, filePath)) {\n            data = BuildCache.getFileData(section.files, filePath)\n        }\n\n        if(!data) {\n            data = {}\n            BuildCache.refreshFileData(section.files, filePath, data)\n        }\n\n        return data\n    }\n\n    save() {\n        if(this.cachedJSON) {\n            this.cache.setJSON(this.cachedJSON)\n        }\n    }\n\n    writeFileData(filePath: string, object: any) {\n        BuildCache.refreshFileData(this.getSection().files, filePath, object)\n    }\n}",
    "import BuildCache from \"../../build-cache\";\n\n/**\n * Abstract file data storage system.\n */\nexport default abstract class PackerStorage {\n    cache: BuildCache;\n\n    constructor(cache: BuildCache) {\n        this.cache = cache;\n    }\n\n    abstract accessFileData(filePath: string): any;\n    abstract writeFileData(filePath: string, data: any): void;\n    abstract save(): void;\n}\n",
    "import Bundler from \"../bundler\";\nimport * as babel from \"@babel/core\";\n\nimport path from \"path\";\nimport generator from \"@babel/generator\"\n\nimport {Timings} from \"../../index\";\nimport AsyncEventEmitter from \"../../async-event-emitter\";\n// @ts-ignore\nimport mergeSourceMap from 'merge-source-map'\nimport PackerCache from \"./packer-cache\";\nimport PackerFile from \"./packer-file\";\nimport PackerASTWatcher from \"./packer-ast-watcher\";\nimport {ParseResult} from \"@babel/core\";\n\nexport interface PackerFileCache {\n    dependencies?: { [key: string]: string }\n    /**\n     * AST of file after babel transformations. Should never be modified\n     * from bundler plugins.\n     */\n    originalAst?: babel.types.File | null;\n    code?: string | null;\n    [key: string]: any\n}\n\nexport interface CachedPackerConfig {\n    babelTransformConfig: babel.TransformOptions,\n    extensions: string[],\n    includeExternalModules: boolean | string[]\n}\n\nexport interface PackerBundleFileInfo {\n    id: string | number,\n    source: string,\n    deps?: { [key: string]: string | number },\n    entry?: boolean,\n    sourceFile?: string\n    globalPath?: string\n}\n\nexport class TraverseContext {\n    metFiles: Set<string> = new Set<string>()\n    cachedEntriesLoaded: number = 0\n    rebuiltEntries: number = 0\n    onlyCompilableFiles: boolean = true\n}\n\nexport class PackerBuildContext extends TraverseContext{\n    bundleCache: PackerBundleFileInfo[] = []\n}\n\n/**\n * This class provides an interface for transforming files\n */\n\nexport default class Packer extends AsyncEventEmitter {\n    bundler: Bundler;\n    config: CachedPackerConfig;\n    babelConfig: Readonly<babel.PartialConfig>;\n    cache: PackerCache;\n    files: Map<string, PackerFile> = new Map<string, PackerFile>()\n    astWatcher: any;\n    babelConfigGenerated: boolean;\n\n    constructor(bundler: Bundler, config: { babelTransformConfig: { presets: any; sourceType: \"script\" | \"module\"; plugins: any[]; sourceMaps: boolean }; extensions: string[]; includeExternalModules: boolean | string[] }) {\n        super()\n        this.bundler = bundler\n        this.config = config\n        this.cache = new PackerCache(this.bundler.config.cache)\n        this.astWatcher = new PackerASTWatcher({\n            packer: this,\n            extensions: this.config.extensions\n        })\n\n        this.babelConfigGenerated = false\n    }\n\n    private updateBabelConfig(filePath: string) {\n        if(!this.babelConfigGenerated) this.generateConfig()\n        this.babelConfig.options.filename = filePath\n        this.babelConfig.options.sourceFileName = filePath\n    }\n\n    /**\n     * Transforms given data with provided sourcemap filename\n     * @param data Source code to transform\n     * @param filePath Path to file for sourcemap (project-relative)\n     */\n    transformFile(data: string, filePath: string): babel.BabelFileResult {\n        this.updateBabelConfig(filePath);\n        return babel.transformSync(data, this.babelConfig.options)\n    }\n\n    parseFile(data: string, filePath: string): babel.types.File {\n        this.updateBabelConfig(filePath);\n        return babel.parseSync(data, this.babelConfig.options) as babel.types.File\n    }\n\n    private generateConfig() {\n        let options = this.config.babelTransformConfig;\n\n        if(!options) return;\n\n        this.babelConfig = babel.loadPartialConfig(options);\n\n        if(!this.babelConfig) return;\n\n        const opts = this.babelConfig.options;\n\n        opts.ast = true\n        opts.cwd = this.bundler.config.projectRoot\n        opts.caller = { name: \"beelder\" }\n    }\n\n    private sourceMapComment(sourceMap: any) {\n        const base64 = Buffer.from(JSON.stringify(sourceMap)).toString('base64');\n        return \"//# sourceMappingURL=data:application/json;charset=utf-8;base64,\" + base64;\n    }\n\n    /**\n     * Generates code from abstract syntax tree\n     * @param ast File tree\n     * @param filePath Path to file for sourcemap (project-relative)\n     * @param originalCode Original file code\n     */\n    public generateCode(ast: babel.types.File | babel.types.Program, filePath: string, originalCode: string) {\n        let generated = generator(ast, {\n            sourceMaps: true,\n            sourceFileName: filePath,\n            sourceRoot: this.bundler.config.projectRoot\n        })\n\n        generated.map.sourcesContent = [ originalCode ]\n\n        return generated.code + \"\\n\" + this.sourceMapComment(generated.map)\n    }\n\n    async bundleSubtree(entry: string): Promise<PackerBundleFileInfo[]> {\n\n        let context = new PackerBuildContext()\n        context.onlyCompilableFiles = false\n        await this.traverse(entry, context, (filePath: string, data: PackerFile) => {\n            context.bundleCache.push({\n                id: filePath,\n                source: data.getTransformedCode(),\n                deps: Object.assign({ }, data.getDependencies()),\n                entry: context.bundleCache.length == 0,\n                sourceFile: path.relative(this.bundler.config.projectRoot, filePath),\n                globalPath: filePath\n            })\n        })\n\n        return context.bundleCache\n    }\n\n    /**\n     * @param entry\n     * @returns true if at least one file was modified\n     */\n    async rebuildSubtree(entry: string): Promise<boolean> {\n        Timings.begin(\"Rebuilding files\")\n        await this.emit(\"before-build\")\n        let context = await this.traverse(entry)\n        await this.emit(\"after-build\")\n        Timings.end(\"Finished rebuilding files (had to rebuild \" + context.rebuiltEntries + \" / \" + (context.cachedEntriesLoaded + context.rebuiltEntries) + \" files)\")\n        return context.rebuiltEntries > 0\n    }\n\n    public static collapseBundleIDs(cache: PackerBundleFileInfo[]) {\n        let fileNames = new Map<string | number, number>()\n        let fileIndex = 0\n\n        for(let fileInfo of cache) {\n            fileNames.set(fileInfo.id, fileIndex)\n            fileInfo.id = fileIndex\n\n            fileIndex++\n        }\n\n        for(let fileInfo of cache) {\n            for(let [key, value] of Object.entries(fileInfo.deps)) {\n                let identifier = fileNames.get(value)\n                if (identifier === undefined) continue\n\n                fileInfo.deps[key] = identifier\n            }\n        }\n    }\n\n    /**\n     * Get file meta-information and cache\n     * @param filePath global file path\n     */\n    getFile(filePath: string) {\n        let file = this.files.get(filePath)\n        if(file) return file\n        file = new PackerFile(this, filePath)\n        this.files.set(filePath, file)\n        return file\n    }\n\n    shouldWalkFile(path: string) {\n        if(path.startsWith(\".\")) return true\n\n        if(this.config.includeExternalModules === true) {\n            return true\n        } else if(Array.isArray(this.config.includeExternalModules)) {\n            return this.config.includeExternalModules.indexOf(path) != -1\n        }\n    }\n\n    /**\n     * Traverses the project tree with given callback function\n     * @param filePath Project entry point to traverse from\n     * @param context Traverse context object to store some useful information. May be null\n     * @param callback Traverse function which will be called for each project file. May be either sync or async\n     */\n    public async traverse(filePath: string, context?: null, callback?: (filePath: string, file: PackerFile) => Promise<void>): Promise<TraverseContext>\n    public async traverse(filePath: string, context?: null, callback?: (filePath: string, file: PackerFile) => Promise<void>): Promise<TraverseContext>\n    public async traverse<T extends TraverseContext>(filePath: string, context?: T, callback?: (filePath: string, file: PackerFile, context: T) => Promise<T>): Promise<void>\n    public async traverse<T extends TraverseContext>(filePath: string, context?: T, callback?: (filePath: string, file: PackerFile, context: T) => void): Promise<T>\n\n    public async traverse<T extends TraverseContext | null>(filePath: string, context?: T, callback?: (filePath: string, file: PackerFile, context: T) => any): Promise<T> {\n\n        let tempContext: TraverseContext = context\n        if(!tempContext) tempContext = new TraverseContext()\n        if(tempContext.metFiles.has(filePath)) return;\n        tempContext.metFiles.add(filePath)\n\n        let file = this.getFile(filePath)\n\n        if(file.cacheIsUpToDate()) {\n            tempContext.cachedEntriesLoaded++\n        } else {\n            tempContext.rebuiltEntries++\n        }\n\n        if(callback) {\n            let result = callback(filePath, file, context)\n            if (result instanceof Promise) {\n                await result\n            }\n        }\n\n        // getDependencies method tries to use the most\n        // efficient method to fetch file dependencies,\n        // but it will rebuild each modified file\n        // automatically. See getDependencies\n        // documentation\n        for(let [name, absolute] of Object.entries(file.getDependencies())) {\n            if(!this.shouldWalkFile(name))\n                continue;\n            if(tempContext.onlyCompilableFiles && !this.getFile(absolute).shouldBeCompiled)\n                continue;\n\n            await this.traverse(absolute, tempContext, callback);\n        }\n\n        return tempContext as T\n    }\n}",
    "\nimport BundlerPlugin from \"../bundler-plugin\";\n\nexport default class BasePlugin extends BundlerPlugin {\n    getBabelPlugins(): any[] | null {\n        return []\n        // return [\n        //     [\"module-resolver\", {\n        //         extensions: [\".js\", \".ts\", \".json\"],\n        //         alias: {\n        //             \"src\": Compiler.path(\"src\")\n        //         }\n        //     }],\n        //     BabelPluginImportDir,\n        //     [\"@babel/plugin-syntax-dynamic-import\"],\n        //     [\"@babel/plugin-syntax-class-properties\"],\n        //     [\"@babel/plugin-proposal-class-properties\", { loose: true }],\n        //     [\"@babel/plugin-transform-typescript\"],\n        //     [\"@babel/plugin-transform-runtime\"],\n        //     [\"@babel/plugin-proposal-export-default-from\"]\n        // ]\n    }\n}",
    "\nimport BundlerPlugin, {BundlerPluginConfig} from '../bundler-plugin'\nimport EventHandlerBlock from \"../../event-handler-block\";\nimport Bundler from \"../bundler\";\nimport traverse, { NodePath } from \"@babel/traverse\";\nimport * as parser from \"@babel/parser\"\nimport { ObjectExpression, Expression, cloneNode } from '@babel/types';\nimport PackerFile from \"../packer/packer-file\";\nimport { Timings } from '../..';\nimport BeelderReference, {BeelderReferenceConfig} from \"../../reference\";\nimport fs from \"fs\"\n\nexport interface CommentReplacerPluginConfig extends BundlerPluginConfig {\n    replacements: CommentReplacementConfig[]\n}\n\nexport interface CommentReplacementConfig {\n    comment: string\n    json?: any\n    file?: BeelderReferenceConfig\n}\n\nexport class CommentReplacement {\n    public readonly comment: string\n    private ast: Expression\n    private readonly json: any;\n    private readonly file: BeelderReference;\n    private readonly plugin: CommentReplacerBundlerPlugin;\n\n    constructor(config: CommentReplacementConfig, plugin: CommentReplacerBundlerPlugin) {\n        this.plugin = plugin\n        this.comment = config.comment\n        if(config.json) this.json = config.json\n        else if(config.file) this.file = new BeelderReference(config.file)\n        else throw new Error(\"Must either provide .file or .json field for json-comment-replacer plugin\")\n    }\n\n    getDependency(): string | null {\n        if(this.file && this.file.isDependency) {\n            return this.file.getDependency()\n        }\n        return null\n    }\n\n    getReplacement() {\n        if(this.json) return parser.parseExpression(JSON.stringify(this.json))\n\n        let reference = this.plugin.bundler.scheme.beelder.resolveReference(this.file)\n        return parser.parseExpression(fs.readFileSync(reference, \"utf8\"))\n    }\n\n    getAST(): Expression {\n        if(!this.ast) {\n            this.ast = this.getReplacement()\n        }\n        return cloneNode(this.ast)\n    }\n}\n\nexport interface CommentReplacerFileCache {\n    cachedComments?: string[]\n}\n\n/**\n * Replaces objects with special comments with pre-defined JSON\n *\n * @example:\n *\n * // before transform:\n * let a = {\n *  // exact-special-comment\n * }\n * // after transform, it's possible to achieve this:\n * let a = { key: \"value\" }\n */\nexport default class CommentReplacerBundlerPlugin extends BundlerPlugin {\n\n    eventHandlerBlock: EventHandlerBlock;\n    replacements: Map<string, CommentReplacement> = new Map()\n\n    constructor(config: CommentReplacerPluginConfig) {\n        super(config)\n\n        this.readConfig(config)\n\n        this.eventHandlerBlock = new EventHandlerBlock()\n        this.eventHandlerBlock.bind(\"after-build\", async () => await this.replaceComments())\n    }\n\n    getDependencies(): string[] | null {\n       let result: string[] | null = null\n\n        for(let [, rule] of this.replacements.entries()) {\n            let dependency = rule.getDependency()\n            if(dependency) {\n                if(!result) result = []\n                result.push(dependency)\n            }\n        }\n\n        return result\n    }\n\n    private readConfig(config: CommentReplacerPluginConfig){\n        if(config.replacements) {\n            for (let replacementConfig of config.replacements) {\n                let replacement = new CommentReplacement(replacementConfig, this)\n                this.replacements.set(replacement.comment, replacement)\n            }\n        }\n    }\n\n    private maybeReplace(path: NodePath<ObjectExpression>, fileCache: CommentReplacerFileCache) {\n        let node = path.node\n\n        if(!node.properties || !node.innerComments || node.properties.length !== 0 || node.innerComments.length !== 1) {\n            return\n        }\n\n        let comment = node.innerComments[0].value.trim()\n\n        fileCache.cachedComments.push(comment)\n\n        let replacement = this.replacements.get(comment)\n        if(!replacement) return\n\n        path.replaceWith(replacement.getAST())\n\n        path.node.innerComments = []\n    }\n\n    private async replaceComments() {\n        Timings.begin(\"Running json-comment-replacer plugin\")\n        if(this.replacements.size) {\n\n\n            let entry = this.bundler.config.source\n\n            await this.bundler.packer.traverse(entry, null, (filePath: string, file: PackerFile) => {\n\n                // Using fast cache to filter out files\n                // that we definitely don't want to transform.\n\n                let storage = file.getFastPluginStorage(CommentReplacerBundlerPlugin.getPluginName()) as CommentReplacerFileCache\n                if (storage.cachedComments) {\n                    let flag = false\n                    for (let comment of storage.cachedComments) {\n                        if (this.replacements.has(comment))\n                            flag = true;\n                    }\n                    if (!flag) return\n                }\n\n                // Transforming file\n\n                storage.cachedComments = []\n                file.clearCodeCache()\n\n                traverse(file.getAST(), {\n                    ObjectExpression: (path: NodePath<ObjectExpression>) => this.maybeReplace(path, storage)\n                })\n            })\n        }\n\n        Timings.end()\n    }\n\n    setCompiler(bundler: Bundler) {\n        super.setCompiler(bundler);\n\n        this.eventHandlerBlock.setTarget(bundler.packer)\n    }\n\n    static getPluginName() {\n        return \"json-comment-replacer\"\n    }\n}",
    "import Bundler from \"../bundler\";\nimport BundlerPlugin, {BundlerPluginConfig} from \"../bundler-plugin\";\nimport EventHandlerBlock from \"../../event-handler-block\";\nimport path from \"path\";\nimport fs from \"fs\";\nimport * as babel from \"@babel/core\";\nimport {Timings} from \"../..\";\nimport {TraverseContext} from \"../packer/packer\";\nimport {Minimatch} from \"minimatch\"\nimport {prepareFileLocation} from \"../../utils\";\nimport BeelderReference, {BeelderReferenceConfig} from \"../../reference\";\n\nexport class ResourceReference {\n    resource: string\n    line: number\n}\n\nexport interface ResourcePluginRuleConfig {\n    pattern: string,\n    target: BeelderReferenceConfig\n}\n\nexport interface BundlerResourcePluginConfig extends BundlerPluginConfig {\n    rules: ResourcePluginRuleConfig[]\n}\n\nexport type ResourceListEntry = [file: string, references: string[]]\nexport type ResourceListFile = ResourceListEntry[]\n\nexport class ResourcePluginRule {\n    pattern: string\n    target: BeelderReference\n\n    constructor(config: ResourcePluginRuleConfig) {\n        this.pattern = config.pattern\n        this.target = new BeelderReference(config.target)\n    }\n}\n\nexport class ResourceSearchContext extends TraverseContext {\n    foundResources: Map<string, ResourceReference[]> = new Map()\n}\n\nexport default class ResourcePlugin extends BundlerPlugin {\n    static resourcePrefix = \"@load-resource:\"\n\n    eventHandlerBlock: EventHandlerBlock;\n    config: BundlerResourcePluginConfig;\n    rules: ResourcePluginRule[]\n\n    constructor(config: BundlerResourcePluginConfig) {\n        super(config)\n\n        this.config = config\n        this.eventHandlerBlock = new EventHandlerBlock()\n\n        this.eventHandlerBlock.bind(\"after-build\", async () => await this.findResources())\n\n        this.rules = this.config.rules.map(config => new ResourcePluginRule(config))\n    }\n\n    setCompiler(bundler: Bundler) {\n        super.setCompiler(bundler);\n\n        this.eventHandlerBlock.setTarget(bundler.packer)\n    }\n\n    private async findResources() {\n        Timings.begin(\"Running resource-plugin\")\n\n        let entry = this.bundler.config.source\n        let context = new ResourceSearchContext()\n        await this.bundler.packer.traverse(entry, context, (filePath, file) => {\n\n            let relative = path.relative(this.bundler.config.projectRoot, filePath)\n\n            // Using fast cache to check if we've already\n            // found all resources for this file\n\n            let storage = file.getFastPluginStorage(ResourcePlugin.getPluginName())\n\n            if(!storage.resources) {\n                // if not, we have to fetch file AST\n                // to find all resources and cache them\n                storage.resources = this.getCommentsFromAST(file.getAST(), relative)\n            }\n\n            if(storage.resources.length) {\n                context.foundResources.set(relative, storage.resources)\n            }\n        })\n\n        let resourceArray = this.getResourceMap(context.foundResources)\n\n        for(let rule of this.rules) {\n            let objectToWrite: ResourceListFile = []\n            let matcher = new Minimatch(rule.pattern)\n\n            for (let [resource, references] of resourceArray.entries()) {\n                if(matcher.match(resource)) objectToWrite.push([resource, references])\n            }\n\n            let destinationPath = this.bundler.scheme.beelder.resolveReference(rule.target)\n\n            if(prepareFileLocation(destinationPath)) {\n                fs.writeFileSync(destinationPath, JSON.stringify(objectToWrite))\n            }\n        }\n\n        Timings.end()\n    }\n\n    private getCommentsFromAST(ast: babel.types.File, filePath: string): ResourceReference[] {\n        let dirname = path.dirname(filePath)\n        let resources: ResourceReference[] = []\n\n        for(let comment of ast.comments) {\n            let commentValue = comment.value.trim()\n            if(commentValue.startsWith(ResourcePlugin.resourcePrefix)) {\n                let resourcePath = commentValue.substr(ResourcePlugin.resourcePrefix.length).replace(/[\"']/g, \"\").trim()\n                if(resourcePath.startsWith(\"/\")) {\n                    resourcePath = resourcePath.substr(1)\n                } else {\n                    resourcePath = path.join(dirname, resourcePath)\n                }\n\n                let resourceToAdd: ResourceReference = {\n                    resource: resourcePath,\n                    line: comment.loc.start.line\n                }\n\n                resources.push(resourceToAdd)\n            }\n        }\n\n        return resources\n    }\n\n    static getPluginName() {\n        return \"resource-plugin\";\n    }\n\n    private getResourceMap(foundResources: Map<string, ResourceReference[]>): Map<string, string[]> {\n        let result = new Map<string, string[]>()\n\n        for(let [filePath, referenceList] of foundResources.entries()) {\n            for (let reference of referenceList) {\n                let list = result.get(reference.resource)\n                let fileAndLine = filePath + \":\" + reference.line\n                if(!list) {\n                    result.set(reference.resource, [fileAndLine])\n                } else {\n                    list.push(fileAndLine)\n                }\n            }\n        }\n\n        return result\n    }\n\n    getTargets(): BeelderReference[] | null {\n        let result: BeelderReference[] | null = null\n\n        for(let rule of this.rules) {\n            if(rule.target.definesTarget) {\n                if(!result) result = []\n                result.push(rule.target)\n            }\n        }\n\n        return result\n    }\n}",
    "import Chalk from \"chalk\";\n\nexport type BeelderReferenceConfig = string & {\n    targetName?: string\n    path?: string\n\n}\n\nexport default class BeelderReference {\n    public isDependency: boolean = false\n    public definesTarget: boolean = false\n    private path: string\n    private targetName?: string\n    public config: BeelderReferenceConfig;\n\n    constructor(config: BeelderReferenceConfig) {\n        this.config = config\n\n        if(typeof config === \"object\") {\n            if(config.targetName) {\n                if(config.path) this.definesTarget = true\n                else this.isDependency = true\n                this.targetName = config.targetName\n            }\n            this.path = config.path\n        } else {\n            this.parseInlineFormat(config)\n        }\n\n        if(!this.path) this.path = null\n    }\n\n    private parseInlineFormat(text: string) {\n        if(/^#[^ =]*$/.test(text)) {\n            this.targetName = text.substr(1)\n            this.isDependency = true\n        } else if(/^#[^ =]* *=.*$/.test(text)) {\n            let equalitySignIndex = text.indexOf(\"=\")\n            this.targetName = text.substring(1, equalitySignIndex).replace(/ *$/,\"\")\n            this.path = text.substr(equalitySignIndex + 1).replace(/^ */,\"\")\n            this.definesTarget = true\n        } else {\n            this.path = text\n        }\n    }\n\n\n    public getDependency(): string | null {\n        if(!this.isDependency) return null\n        return this.targetName\n    }\n\n    public getDefinedTarget(): string | null {\n        if(!this.definesTarget) return null\n        return this.targetName\n    }\n\n    public getPath(): string | null {\n        return this.path\n    }\n\n    public getConsoleName(): string {\n        if(this.definesTarget || this.isDependency) {\n            return Chalk.green(this.targetName)\n        } else {\n            return Chalk.blueBright(this.path)\n        }\n    }\n}",
    "import Beelder, {BeelderActionConfig} from \"./beelder\";\nimport BeelderAction from \"./action\";\nimport Timings from \"./timings\";\nimport Chalk from \"chalk\";\nimport BeelderReference, {BeelderReferenceConfig} from \"./reference\";\nimport {concatOptionalArrays} from \"./utils\";\n\nexport interface BeelderSchemeConfig {\n    steps: [BeelderActionConfig]\n    targets: [BeelderReferenceConfig]\n}\n\nexport default class BeelderScheme {\n\n    public steps: BeelderAction[] = []\n    public explicitTargets: BeelderReference[] = []\n    private config: BeelderSchemeConfig;\n    public beelder: Beelder;\n    public name: string;\n    \n    constructor(name: string, config: BeelderSchemeConfig, beelder: Beelder) {\n        this.name = name\n        this.beelder = beelder\n        this.config = config\n\n        this.loadTargets()\n        this.loadSteps()\n    }\n\n    private loadTargets() {\n        if(!this.config.targets) return\n\n        for(let referenceConfig of this.config.targets) {\n            let reference = new BeelderReference(referenceConfig)\n            if(!reference.definesTarget) throw new Error(\"References listed in 'targets' must define target\")\n            this.explicitTargets.push(reference)\n        }\n    }\n\n    private loadSteps() {\n        if(!this.config.steps) return\n\n        for(let step of this.config.steps) {\n            const ActionClass = Beelder.actions.get(step.action)\n            if(!ActionClass) {\n                throw new Error(\"No such action: '\" + step.action + \"'\")\n            }\n            const action = new ActionClass(step, this)\n            this.steps.push(action)\n        }\n    }\n\n    public getDependencies(): string[] {\n        let dependencies: string[] = []\n\n        for(let step of this.steps) {\n            dependencies = concatOptionalArrays(dependencies, step.getDependencies())\n        }\n\n        return dependencies\n    }\n\n    public getTargets(): BeelderReference[] {\n        let targets: BeelderReference[] = []\n\n        for(let step of this.steps) {\n            targets = concatOptionalArrays(targets, step.getTargets())\n        }\n\n        targets = concatOptionalArrays(targets, this.explicitTargets)\n\n        return targets\n    }\n\n    public async run() {\n        let coloredSchemeName = Chalk.magenta(this.name)\n        Timings.begin(\"Running '\" + coloredSchemeName + \"'\")\n\n        for(let step of this.steps) {\n            await step.run()\n        }\n\n        Timings.end(\"Finished running '\" + coloredSchemeName + \"'\")\n    }\n}",
    "\nimport BeelderScheme from \"../scheme\";\nimport BaseAction, {BaseActionConfig} from \"../base-scheme\";\nimport Timings from \"../timings\";\nimport Bundler from \"../javascript-bundler/bundler\";\nimport BeelderReference from \"../reference\";\nimport {concatOptionalArrays} from \"../utils\";\n\nexport interface BundleJavascriptActionConfig extends BaseActionConfig {\n    compilerOptions: any\n    cacheSection: string | null\n}\n\n/**\n * The class that implements bundle-javascript beelder action.\n * This action may be used multiple times in single build action.\n * If \"target\" field is omitted, project will be rebuilt in order\n * to update caches.\n *\n * The following parameters must be the same in all dependent\n * configurations (which share common source files):\n * - `compilerOptions.babelPlugins`\n * - `compilerOptions.babelPresets`\n * - `compilerOptions.babelSourceType`\n * - `includeExternalModules`\n */\n\nexport default class BundleJavascriptAction extends BaseAction {\n\n    static readonly actionName: string = \"bundle-javascript\"\n    readonly compilerOptions: any;\n    bundler: Bundler;\n\n    constructor(config: BundleJavascriptActionConfig, scheme: BeelderScheme) {\n        super(config, scheme);\n        \n        this.compilerOptions = config.compilerOptions\n        if(config.cacheSection) this.cache = this.cache.getSection(config.cacheSection)\n\n\n        this.createBundler()\n    }\n\n   async runCompiler() {\n        await this.bundler.build()\n    }\n\n    getDependencies(): string[] | null {\n        return concatOptionalArrays(super.getDependencies(), this.bundler.getDependencies());\n    }\n\n    getTargets(): BeelderReference[] | null {\n        return concatOptionalArrays(super.getTargets(), this.bundler.getTargets());\n    }\n\n    async run() {\n        let sourceName = this.source.getConsoleName();\n\n        Timings.begin(\"Building \" + sourceName)\n\n        await this.runCompiler()\n\n        Timings.end(\"Finished building \" + sourceName)\n    }\n\n    private createBundler() {\n        let source = this.scheme.beelder.resolveReference(this.source)\n        let destination = this.scheme.beelder.resolveReference(this.target)\n\n        let compilerOptions = {\n            source: source,\n            destination: destination,\n            cache: this.cache,\n            projectRoot: this.scheme.beelder.projectRoot,\n            buildAction: this,\n            scheme: this.scheme\n        }\n\n        if (this.compilerOptions) {\n            Object.assign(compilerOptions, this.compilerOptions)\n        }\n\n        this.bundler = new Bundler(compilerOptions);\n    }\n}",
    "import BeelderScheme from \"../scheme\";\nimport fs from \"fs\"\nimport {ResourceListEntry, ResourceListFile } from \"../javascript-bundler/plugins/resource-plugin\";\nimport BaseAction, { BaseActionConfig } from \"../base-scheme\";\nimport BuildCache from \"../build-cache\";\nimport SASS from \"sass\"\nimport {compareArrayValues, prepareFileLocation} from \"../utils\";\nimport { Timings } from \"..\";\n\nexport interface CompileSCSSActionConfig extends BaseActionConfig {\n\n}\n\n// TODOS:\n// Handle file read errors\n\n/**\n * Scheme action which compiles all SCSS files from resource list\n * into single CSS file.\n */\n\nexport default class CompileSCSSSchemeAction extends BaseAction {\n    static readonly actionName: string = \"compile-scss\"\n    config: CompileSCSSActionConfig;\n\n    constructor(config: CompileSCSSActionConfig, scheme: BeelderScheme) {\n        super(config, scheme)\n        this.config = config\n    }\n\n    async run(): Promise<void> {\n        Timings.begin(\"Updating CSS resources\")\n\n        let source = this.scheme.beelder.resolveReference(this.source)\n        let destination = this.scheme.beelder.resolveReference(this.target)\n        let resourceFile = JSON.parse(fs.readFileSync(source, \"utf8\")) as ResourceListFile\n        let resourceList = resourceFile.map(file => file[0]);\n\n        let cache = this.cache.getJSON()\n        if(!cache.files) cache.files = {}\n        if(!cache.resultCache) cache.resultCache = {}\n\n        let resultCache = cache.resultCache[destination]\n        if(!resultCache) {\n            resultCache = {}\n            cache.resultCache[destination] = resultCache\n        }\n\n\n        let shouldUpdate = this.schemeFileCacheOutdated(resultCache, resourceList);\n\n        if(!shouldUpdate) shouldUpdate = this.anyFilesUpdated(cache.files, resourceList);\n\n        if(shouldUpdate) {\n            Timings.begin(\"Recompiling SCSS files\")\n            if(prepareFileLocation(destination)) {\n                fs.writeFileSync(destination, this.recompileFiles(resourceFile, cache.files), \"utf8\")\n            } else {\n                console.error(\"Could not create target directory. Please, check permissions\")\n            }\n            resultCache.resourceList = resourceList\n            this.cache.setJSON(cache)\n            Timings.end()\n        }\n\n        Timings.end()\n    }\n\n    private schemeFileCacheOutdated(resultCache: any, resourceList: string[]) {\n        if(resultCache && resultCache.resourceList) {\n            return !compareArrayValues(resultCache.resourceList, resourceList)\n        }\n        return true\n    }\n\n    private anyFilesUpdated(fileCache: any, resourceList: string[]) {\n        for(let resource of resourceList) {\n            if(BuildCache.fileRequiresRefresh(fileCache, resource)) return true\n        }\n        return false\n    }\n\n    private recompileFiles(resourceFile: ResourceListFile, fileCache: any) {\n        let compiledStylesheets = new Map<string, string>();\n\n        for(let resourceInfo of resourceFile) {\n            let resourcePath = resourceInfo[0]\n            // TODO: print error if file does not exist\n            //let resourceReferences = resourceInfo[1]\n            let compiledSource: string\n\n            if(BuildCache.fileRequiresRefresh(fileCache, resourcePath)) {\n                compiledSource = this.compileCSS(resourceInfo)\n                BuildCache.refreshFileData(fileCache, resourcePath, compiledSource)\n            } else {\n                compiledSource = BuildCache.getFileData(fileCache, resourcePath)\n            }\n\n            compiledStylesheets.set(resourcePath, compiledSource);\n        }\n\n        return Array.from(compiledStylesheets.values()).join(\"\\n\")\n    }\n\n    private compileCSS(resourceInfo: ResourceListEntry): string {\n        let file = fs.readFileSync(resourceInfo[0], \"utf8\")\n        let rendered = SASS.renderSync({\n            data: file,\n            outputStyle: \"expanded\"\n        })\n\n        return rendered.css.toString(\"utf8\")\n    }\n}",
    "import BeelderScheme from \"../scheme\";\nimport BaseAction, {BaseActionConfig} from \"../base-scheme\";\nimport path from \"path\";\nimport {copyDirectory, prepareDirectory} from \"../utils\";\nimport fs from \"fs\"\nimport Timings from \"../timings\";\n\nexport interface CopyActionConfig extends BaseActionConfig {\n    \n}\n\nexport default class CopyAction extends BaseAction {\n\n    static readonly actionName: string = \"copy\"\n\n    constructor(config: CopyActionConfig, scheme: BeelderScheme) {\n        super(config, scheme);\n    }\n\n    async run(): Promise<void> {\n        Timings.begin(\"Copying \" + this.source.getConsoleName() + \" to \" + this.target.getConsoleName())\n\n        let source = this.scheme.beelder.resolveReference(this.source)\n        let destination = this.scheme.beelder.resolveReference(this.target)\n\n        let sourceStat;\n\n        try {\n            sourceStat = await fs.promises.stat(source)\n        } catch(e) {\n            throw new Error(\"Copying failed: \" + e.message)\n        }\n\n        let dirname: string\n\n        if(destination.endsWith(path.sep)) {\n            // Copying something in directory, adding filename explicitly\n\n            dirname = destination\n            destination = path.join(destination, path.basename(source))\n        } else {\n            // Copying file on exact new location\n\n            dirname = path.dirname(destination)\n        }\n\n        if(!await prepareDirectory(dirname)) {\n            throw new Error(\"Could not create destination directory\")\n        }\n\n        if(sourceStat.isDirectory()) {\n            await copyDirectory(source, destination)\n        } else {\n            await fs.promises.copyFile(source, destination)\n        }\n\n        Timings.end()\n    }\n}",
    "import BeelderScheme from \"../scheme\";\nimport fs from \"fs\";\nimport {ResourceListFile} from \"../javascript-bundler/plugins/resource-plugin\";\nimport path from \"path\";\nimport BaseAction, { BaseActionConfig } from \"../base-scheme\";\nimport {prepareFileLocation} from \"../utils\";\n\nexport interface CreateShaderLibraryActionConfig extends BaseActionConfig {\n\n}\n\nexport default class CreateShaderLibraryAction extends BaseAction {\n    static readonly actionName: string = \"create-shader-library\"\n    config: CreateShaderLibraryActionConfig;\n\n    constructor(config: CreateShaderLibraryActionConfig, scheme: BeelderScheme) {\n        super(config, scheme)\n        this.config = config\n    }\n\n    async run(): Promise<void> {\n        let source = this.scheme.beelder.resolveReference(this.source)\n        let destination = this.scheme.beelder.resolveReference(this.target)\n        let resourceArray = JSON.parse(fs.readFileSync(source, \"utf8\")) as ResourceListFile\n\n        let library: { [key: string]: string } = {}\n\n        for(let resourceInfo of resourceArray) {\n            let resourcePath = resourceInfo[0]\n            // TODO: print error if file does not exist\n            //let resourceReferences = resourceInfo[1]\n\n            let absolutePath = path.join(this.scheme.beelder.getAbsolutePath(resourcePath))\n\n            library[resourcePath] = fs.readFileSync(absolutePath, \"utf8\")\n        }\n\n        let code = JSON.stringify(library)\n        if(prepareFileLocation(destination)) {\n            fs.writeFileSync(destination, code, \"utf8\")\n        } else {\n            console.error(\"Could not create target directory. Please, check permissions\")\n        }\n    }\n}",
    "import BeelderScheme from \"../scheme\";\nimport fs from \"fs\"\nimport Timings from \"../timings\";\nimport BeelderReference from \"../reference\";\nimport {BeelderActionConfig} from \"../beelder\";\nimport BeelderAction from \"../action\";\n\nexport interface DeleteActionConfig extends BeelderActionConfig {\n    target: string\n}\n\nexport default class DeleteAction extends BeelderAction {\n\n    static readonly actionName: string = \"delete\"\n    target: BeelderReference;\n\n    constructor(config: DeleteActionConfig, scheme: BeelderScheme) {\n        super(config, scheme);\n\n        this.target = new BeelderReference(config.target)\n    }\n\n    private deleteFile(file: string) {\n        try {\n            let stat = fs.statSync(file)\n\n            if (stat.isDirectory()) {\n                fs.rmdirSync(file, { recursive: true })\n            } else {\n                fs.rmSync(file)\n            }\n        } catch(ignored) {}\n    }\n\n    async run(): Promise<void> {\n        Timings.begin(\"Deleting \" + this.target.getConsoleName())\n\n        let target = this.scheme.beelder.resolveReference(this.target)\n\n        this.deleteFile(target)\n\n        Timings.end()\n    }\n}",
    "import BeelderScheme from \"../scheme\";\nimport BeelderAction from \"../action\";\nimport { BeelderActionConfig } from \"../beelder\";\nimport BeelderReference from \"../reference\";\n\nexport interface RequireTargetActionConfig extends BeelderActionConfig {\n    target: string\n}\n\nexport default class RequireTargetAction extends BeelderAction {\n    static readonly actionName: string = \"require-target\"\n    target: BeelderReference;\n\n    constructor(config: RequireTargetActionConfig, scheme: BeelderScheme) {\n        super(config, scheme)\n        this.target = new BeelderReference(config.target)\n\n        if(this.target.definesTarget) {\n            throw new Error(\"run-command target field must specify existing target\")\n        }\n        if(!this.target.isDependency) {\n            throw new Error(\"run-command target field must specify dependency target\")\n        }\n    }\n\n    getDependencies(): string[] | null {\n        return [this.target.getDependency()]\n    }\n}\n",
    "\nimport BeelderScheme from \"../scheme\";\nimport BaseAction, {BaseActionConfig} from \"../base-scheme\";\n//@ts-ignore\nimport atlaspack from \"atlaspack\";\nimport Canvas from \"canvas\";\nimport fs from \"fs\"\nimport path from \"path\"\nimport Timings from \"../timings\";\nimport Chalk from \"chalk\";\nimport {readdirDeep, compareArrayValues, trimExtension, prepareDirectory} from \"../utils\"\nimport BuildCache, {FileListCache} from \"../build-cache\";\n\nexport interface TextureAtlasActionConfig extends BaseActionConfig {\n    atlasSize: number\n}\n\nexport interface AtlasCreationTexture {\n    name: string\n    image: Canvas.Image\n}\n\nexport class AtlasCreationSession {\n    imagePaths: string[]\n    \n    canvases: Canvas.Canvas[] = []\n    contexts: Canvas.CanvasRenderingContext2D[] = []\n    atlases: atlaspack.Atlas[] = []\n    atlasDescriptors: atlaspack.Rect[] = []\n    texturesRoot: string\n    atlasSize: number\n    texturesToPack: AtlasCreationTexture[]\n\n    constructor(texturesRoot: string, atlasSize: number) {\n        this.texturesRoot = texturesRoot\n        this.atlasSize = atlasSize\n    }\n\n    async readTextureList() {\n        this.imagePaths = (await readdirDeep(this.texturesRoot)).filter(file => file.endsWith(\".png\"))\n    }\n\n    async checkCacheRelevance(cache: TextureAtlasActionCache): Promise<boolean> {\n        if(!cache.directorySubtrees) return false\n        if(!cache.textureInfo) return false\n\n        let cachedSubtree = cache.directorySubtrees[this.texturesRoot]\n        if(!cachedSubtree) return false\n\n        if(!compareArrayValues(cachedSubtree, this.imagePaths)) return false\n\n        for(let imagePath of this.imagePaths) {\n            let absolutePath = path.join(this.texturesRoot, imagePath)\n            if(await BuildCache.fileRequiresRefresh(cache.textureInfo, absolutePath)) return false\n        }\n\n        return true\n    }\n\n    writeCache(cache: TextureAtlasActionCache) {\n        if(!cache.directorySubtrees) cache.directorySubtrees = {}\n        if(!cache.textureInfo) cache.textureInfo = {}\n\n        cache.directorySubtrees[this.texturesRoot] = this.imagePaths\n        for(let imagePath of this.imagePaths) {\n            let absolutePath = path.join(this.texturesRoot, imagePath)\n\n            BuildCache.refreshFileData(cache.textureInfo, absolutePath)\n        }\n    }\n\n    static webglRect(rect: atlaspack.Rect, canvas: Canvas.Canvas) {\n        return {\n            x: (rect.x + 1) / canvas.width,\n            y: (rect.y + 1) / canvas.height,\n            w: (rect.w - 2) / canvas.width,\n            h: (rect.h - 2) / canvas.height\n        }\n    }\n\n    createCanvases() {\n        let size = this.atlasSize\n        do {\n            let canvas = Canvas.createCanvas(size, size);\n            let ctx = canvas.getContext('2d');\n            let atlas = atlaspack(canvas);\n\n            atlas.tilepad = true\n\n            this.canvases.push(canvas)\n            this.contexts.push(ctx)\n            this.atlases.push(atlas)\n\n            size >>= 1\n        } while(size > 64)\n    }\n\n    drawTextures() {\n        for(let image of this.texturesToPack) {\n            let mipMapSize = this.atlasSize\n            let scale = 1\n\n            for(let j = 0; this.canvases[j]; j++) {\n                const rect = this.atlases[j].pack({\n                    width: image.image.width * scale + 2,\n                    height: image.image.height * scale + 2\n                }).rect;\n\n                if(!rect) {\n                    this.canvases[j] = null\n                    break\n                }\n\n                if(!this.atlasDescriptors[j]) this.atlasDescriptors[j] = {}\n                this.atlasDescriptors[j][image.name] = AtlasCreationSession.webglRect(rect, this.canvases[j])\n\n                AtlasCreationSession.drawTexture(this.canvases[j], this.contexts[j], image, rect)\n\n                mipMapSize >>= 1\n                scale /= 2\n            }\n        }\n    }\n\n    async readTextures() {\n        let textures: AtlasCreationTexture[] = []\n\n        await Promise.all(this.imagePaths.map(file => new Promise<void>((resolve, reject) => {\n            const image = new Canvas.Image();\n\n            image.onload = () => {\n                textures.push({\n                    name: trimExtension(file),\n                    image: image\n                })\n                resolve()\n            }\n\n            // node-canvas sometimes throws ENOENT without any reason,\n            // so we help him by reading the file for him.\n\n            const texturePath = path.resolve(this.texturesRoot, file)\n            const buffer = fs.readFileSync(texturePath)\n\n            image.onerror = reject\n            image.src = buffer\n        })))\n\n        textures.sort((left, right) => {\n            return right.image.width * right.image.height - left.image.width * left.image.height\n        })\n\n        this.texturesToPack = textures\n    }\n\n    static drawTexture(canvas: Canvas.Canvas, ctx: Canvas.CanvasRenderingContext2D, img: AtlasCreationTexture, rect: atlaspack.Rect) {\n        // Internal\n        ctx.drawImage(img.image, rect.x + 1, rect.y + 1, rect.w - 2, rect.h - 2)\n\n        // Left\n        ctx.drawImage(canvas, rect.x + 1, rect.y + 1, 1, rect.h - 2, rect.x, rect.y + 1, 1, rect.h - 2)\n        // Right\n        ctx.drawImage(canvas, rect.x + rect.w - 2, rect.y + 1, 1, rect.h - 2, rect.x + rect.w - 1, rect.y + 1, 1, rect.h - 2)\n        // Top\n        ctx.drawImage(canvas, rect.x + 1, rect.y + 1, rect.w - 2, 1, rect.x + 1, rect.y, rect.w - 2, 1)\n        // Bottom\n        ctx.drawImage(canvas, rect.x + 1, rect.y + rect.h - 2, rect.w - 2, 1, rect.x + 1, rect.y + rect.h - 1, rect.w - 2, 1)\n\n        // Left-top\n        ctx.drawImage(canvas, rect.x + 1, rect.y + 1, 1, 1, rect.x, rect.y, 1, 1)\n        // Right-top\n        ctx.drawImage(canvas, rect.x + rect.w - 2, rect.y + 1, 1, 1, rect.x + rect.w - 1, rect.y, 1, 1)\n        // Left-bottom\n        ctx.drawImage(canvas, rect.x + 1, rect.y + rect.h - 2, 1, 1, rect.x, rect.y + rect.h - 1, 1, 1)\n        // Right-bottom\n        ctx.drawImage(canvas, rect.x + rect.w - 2, rect.y + rect.h - 2, 1, 1, rect.x + rect.w - 1, rect.y + rect.h - 1, 1, 1)\n    }\n\n    async writeTextures(destination: string) {\n        for(let j = 0; j < this.canvases.length; j++) {\n            if(!this.canvases[j]) break\n\n            await fs.promises.writeFile(path.resolve(destination, \"atlas-mipmap-level-\" + j + \".png\"), this.canvases[j].toBuffer());\n            await fs.promises.writeFile(path.resolve(destination, \"atlas-mipmap-level-\" + j + \".json\"), JSON.stringify(this.atlasDescriptors[j]));\n        }\n    }\n}\n\nexport interface TextureAtlasActionCache {\n    directorySubtrees: { [key: string]: string[] | null }\n    textureInfo: FileListCache\n}\n\nexport default class TextureAtlasAction extends BaseAction {\n\n    config: TextureAtlasActionConfig\n\n    static readonly actionName: string = \"texture-atlas\"\n\n    constructor(config: TextureAtlasActionConfig, scheme: BeelderScheme) {\n        super(config, scheme);\n        this.config = config\n    }\n\n    async run(): Promise<any> {\n\n        let source = this.scheme.beelder.resolveReference(this.source)\n        let destination = this.scheme.beelder.resolveReference(this.target)\n\n        if(!prepareDirectory(destination)) throw new Error(\"Unable to create destination folder\")\n\n        Timings.begin(\"Creating texture atlases of \" + this.source.getConsoleName())\n\n        let cacheJSON = await this.cache.getJSON() as TextureAtlasActionCache\n\n        let context = new AtlasCreationSession(source, this.config.atlasSize ?? 1024)\n\n        Timings.begin(\"Reading directory\")\n        await context.readTextureList()\n        Timings.end()\n\n        Timings.begin(\"Checking cache\")\n        if(await context.checkCacheRelevance(cacheJSON)) {\n            Timings.end()\n            Timings.end(\"Textures has not been updated, used cached result\")\n            return\n        } else {\n            Timings.end(\"Textures has been updated, should refresh atlas\")\n        }\n\n        Timings.begin(\"Reading textures\")\n        await context.readTextures()\n        Timings.end()\n\n        Timings.begin(\"Allocating canvases\")\n        context.createCanvases()\n        Timings.end()\n\n        Timings.begin(\"Drawing atlases\")\n        context.drawTextures()\n        Timings.end()\n\n        Timings.begin(\"Writing atlases\")\n        await context.writeTextures(destination)\n        Timings.end()\n\n        Timings.begin(\"Saving caches\")\n        context.writeCache(cacheJSON)\n        await this.cache.setJSON(cacheJSON)\n        Timings.end()\n\n        Timings.end(\"Finished creating texture atlas\");\n    }\n}",
    "\nimport util from 'util'\nimport Chalk from 'chalk'\n\nclass Entry {\n    hasInlinedText: boolean\n    public date: number;\n    public title: string;\n\n    constructor(title: string) {\n        this.title = title\n        this.date = Date.now()\n        this.hasInlinedText = false\n    }\n}\n\nexport default class Timings {\n    private static mutedStackIndex?: number = null;\n\n    static stdoutWriteHandler?: (data: any) => boolean = null\n    static stderrWriteHandler?: (data: any) => boolean = null\n\n    static stdoutShouldLinefeed = false\n    static stdoutMarkMessage = false\n\n    static logPrefix: string = Chalk.yellow.bold(\"[ LOG ]\") + Chalk.gray(\": \")\n    static errPrefix: string = Chalk.red.bold(\"[ ERR ]\") + Chalk.gray(\": \")\n\n    static timingColor: Chalk.Chalk = Chalk.cyan\n\n    static stack: Entry[] = []\n\n    private static tab() {\n        return new Array(this.stack.length + 1).join(Chalk.gray(\"- \"))\n    }\n\n    static muteSubtasks() {\n        if(this.mutedStackIndex === null)\n            this.mutedStackIndex = this.stack.length\n    }\n\n    static unmuteSubtasks() {\n        if(this.stack.length === this.mutedStackIndex) this.mutedStackIndex = null\n    }\n\n    static begin(title: string) {\n        this.stdoutMarkMessage = false\n\n        if(this.stack.length === 0) {\n            this.bindStdout();\n        }\n\n        process.stdout.write(title + Chalk.gray(\":\"))\n\n        this.stdoutMarkMessage = true\n        this.stdoutShouldLinefeed = true\n\n        this.stack.push(new Entry(title))\n    }\n\n    static getStackState(): number {\n        return this.stack.length\n    }\n\n    static setStackState(length: number, reason?: string): void {\n        while(this.stack.length > length) {\n            if(reason) {\n                this.end(reason.replace(\"%s\", this.stack[this.stack.length - 1].title))\n            } else {\n                this.end()\n            }\n        }\n    }\n\n    static perform(title: string, task: () => void): void\n    static perform(title: string, task: () => Promise<void>): Promise<void>\n    static perform(title: string, task: (() => void) | (() => Promise<void>)): void | Promise<void> {\n        this.begin(title)\n\n        if(util.types.isAsyncFunction(task)) {\n            return (task() as Promise<void>).then(() => this.end())\n        }\n\n        task()\n        this.end()\n    }\n\n    static end(description?: string) {\n        if(this.stack.length === this.mutedStackIndex) this.mutedStackIndex = null\n        let task = this.stack.pop()\n\n        let time = ((Date.now() - task.date) / 1000).toFixed(3)\n\n        this.stdoutMarkMessage = false\n\n        if (task.hasInlinedText) {\n            if(!description) {\n                description = task.title\n            }\n            process.stdout.write(description + Chalk.gray(\": \") + this.timingColor(\"[\" + time + \"s]\"))\n            this.stdoutShouldLinefeed = true\n        } else {\n            this.stdoutShouldLinefeed = false\n            if(description) {\n                this.stdoutShouldLinefeed = false\n                process.stdout.write(\"\\r\\x1b[K\" + this.tab() + description + Chalk.gray(\":\"))\n            }\n            process.stdout.write(this.timingColor(\" [\" + time + \"s]\"))\n            this.stdoutShouldLinefeed = true\n        }\n\n        this.stdoutMarkMessage = true\n\n        if(this.stack.length === 0) {\n            this.unbindStdout();\n        }\n    }\n\n    static bindStdout() {\n        this.stdoutWriteHandler = process.stdout.write\n        this.stderrWriteHandler = process.stderr.write\n\n        process.stdout.write = (data: any): boolean => {\n            this.writeHandler(data, false)\n            return true\n        }\n\n        process.stderr.write = (data: any): boolean => {\n            this.writeHandler(data, true)\n            return true\n        }\n    }\n\n    private static writeHandler(text: string, isError: boolean) {\n\n        if(this.mutedStackIndex !== null) return\n\n        if(this.stack.length)\n            this.stack[this.stack.length - 1].hasInlinedText = true\n\n        if (this.stdoutShouldLinefeed) {\n            text = \"\\n\" + text;\n            this.stdoutShouldLinefeed = false;\n        } else if(this.stdoutMarkMessage) {\n            if (isError) text = this.errPrefix + text;\n            else         text = this.logPrefix + text;\n        }\n\n        if(text[text.length - 1] === \"\\n\") {\n            text = text.substr(0, text.length - 1)\n            this.stdoutShouldLinefeed = true\n        }\n\n        if(this.stdoutMarkMessage) {\n            text = text.replace(/\\n(?!$)/g, \"\\n\" + this.tab() + (isError ? this.errPrefix : this.logPrefix));\n        } else {\n            text = text.replace(/\\n/g, \"\\n\" + this.tab());\n        }\n\n        this.stdoutWriteHandler.call(process.stdout, text);\n    }\n\n    private static unbindStdout() {\n        process.stdout.write = this.stdoutWriteHandler\n        process.stderr.write = this.stderrWriteHandler\n\n        if(this.stdoutShouldLinefeed) {\n            process.stdout.write(\"\\n\")\n            this.stdoutShouldLinefeed = false\n        }\n    }\n}",
    "\nimport fs from \"fs\";\nimport path from \"path\";\n\nexport function readdirDeep(directory: string): string[]\nexport function readdirDeep(directory: string, array: string[], base: string): string[]\nexport function readdirDeep(directory: string, array: string[] = [], base: string = \"\"): string[] {\n\n    if (!array) array = []\n    if (!base) base = \"\"\n\n    if (fs.statSync(directory).isDirectory()) {\n        fs.readdirSync(directory).map(async file => {\n            let item = path.join(directory, file)\n            let subbase = path.join(base, file)\n            array.push(subbase)\n\n            readdirDeep(item, array, subbase)\n        })\n    }\n    return array\n}\n\nexport function trimExtension(fileName: string): string {\n    const fragments = fileName.split(\".\");\n    if(fragments.length > 1) fragments.pop()\n    return fragments.join(\".\")\n}\n\nexport function prepareDirectory(directory: string): boolean {\n    try {\n        fs.accessSync(directory)\n    } catch(e) {\n        try {\n            fs.mkdirSync(directory, {recursive: true})\n        } catch(e) {\n            return false\n        }\n    }\n\n    return true\n}\n\nexport function prepareFileLocation(filePath: string): boolean {\n    let directoryPath = path.dirname(filePath)\n    try {\n        fs.accessSync(directoryPath)\n    } catch(e) {\n        try {\n            fs.mkdirSync(directoryPath, { recursive: true })\n        } catch(e) {\n            return false\n        }\n    }\n\n    return true\n}\n\nexport function compareArrayValues(arr1: any[], arr2: any[]): boolean {\n    let dictionary = new Map<any, number>()\n\n    for(let element of arr1) dictionary.set(element, 1)\n    for(let element of arr2) {\n        let existed = dictionary.get(element)\n        if(!existed) return false\n        dictionary.set(element, 2)\n    }\n\n    for(let value of dictionary.values()) {\n        if(value === 1) return false\n    }\n\n    return true\n}\n\nexport function copyDirectoryContents(from: string, to: string) {\n    try {\n        fs.mkdirSync(to);\n    } catch (e) {}\n\n    for (let element of fs.readdirSync(from)) {\n        const stat = fs.lstatSync(path.join(from, element));\n        if (stat.isFile()) {\n            fs.copyFileSync(path.join(from, element), path.join(to, element));\n        } else if (stat.isSymbolicLink()) {\n            fs.symlinkSync(fs.readlinkSync(path.join(from, element)), path.join(to, element));\n        } else if (stat.isDirectory()) {\n            copyDirectoryContents(path.join(from, element), path.join(to, element));\n        }\n    }\n}\n\nexport function copyDirectory(from: string, to: string) {\n    if (to.endsWith(path.sep)) {\n        to = path.join(to, path.basename(from))\n    }\n    copyDirectoryContents(from, to)\n}\n\n/**\n * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n *\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n *\n * @param {string} key ASCII only\n * @param {number} seed Positive integer only\n * @return {number} 32-bit positive integer hash\n */\n\nexport function murmurhash3_32_gc(key: string, seed: number) {\n    let remainder, bytes, h1, h1b, c1, c2, k1, i;\n\n    remainder = key.length & 3; // key.length % 4\n    bytes = key.length - remainder;\n    h1 = seed;\n    c1 = 0xcc9e2d51;\n    c2 = 0x1b873593;\n    i = 0;\n\n    while (i < bytes) {\n        k1 =\n            ((key.charCodeAt(i) & 0xff)) |\n            ((key.charCodeAt(++i) & 0xff) << 8) |\n            ((key.charCodeAt(++i) & 0xff) << 16) |\n            ((key.charCodeAt(++i) & 0xff) << 24);\n        ++i;\n\n        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n    }\n\n    k1 = 0;\n\n    // noinspection FallThroughInSwitchStatementJS\n    switch (remainder) {\n        case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n        case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n        case 1: k1 ^= (key.charCodeAt(i) & 0xff);\n\n            k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n            k1 = (k1 << 15) | (k1 >>> 17);\n            k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n            h1 ^= k1;\n    }\n\n    h1 ^= key.length;\n\n    h1 ^= h1 >>> 16;\n    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n    h1 ^= h1 >>> 13;\n    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n    h1 ^= h1 >>> 16;\n\n    return h1 >>> 0;\n}\n\nexport function hashToUUIDString32(hash: number) {\n    let result = \"\";\n\n    for(let i = 7; i >= 0; i--) {\n        result += Math.abs(hash % 16).toString(16);\n        hash >>= 4;\n        if((i % 4 == 0) && i > 0) result += '-';\n    }\n\n    return result;\n}\n\nexport function mapToObject<T>(map: Map<string, T>): { [key: string]: T } {\n    const obj: { [key: string]: T } = { };\n    for (const [key, value] of map.entries()) {\n        obj[key] = value;\n    }\n    return obj\n}\n\nexport function concatOptionalArrays<T>(arrayA: T[] | null, arrayB: T[] | null) {\n\n    if(arrayB && arrayB.length) {\n        if(!arrayA) arrayA = []\n        for(let target of arrayB) {\n            arrayA.push(target)\n        }\n    }\n\n    return arrayA\n}",
    "\nimport Timings from './timings'; export { Timings }\nimport Beelder from \"./beelder\"; export { Beelder }"
  ]
}